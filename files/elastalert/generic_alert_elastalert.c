/*
 *                                 Apache License
 *                          Version 2.0, January 2004
 *                       http://www.apache.org/licenses/
 *
 *  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *  1. Definitions.
 *
 *     "License" shall mean the terms and conditions for use, reproduction,
 *     and distribution as defined by Sections 1 through 9 of this document.
 *
 *     "Licensor" shall mean the copyright owner or entity authorized by
 *     the copyright owner that is granting the License.
 *
 *     "Legal Entity" shall mean the union of the acting entity and all
 *     other entities that control, are controlled by, or are under common
 *     control with that entity. For the purposes of this definition,
 *     "control" means (i) the power, direct or indirect, to cause the
 *     direction or management of such entity, whether by contract or
 *     otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *     outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *     "You" (or "Your") shall mean an individual or Legal Entity
 *     exercising permissions granted by this License.
 *
 *     "Source" form shall mean the preferred form for making modifications,
 *     including but not limited to software source code, documentation
 *     source, and configuration files.
 *
 *     "Object" form shall mean any form resulting from mechanical
 *     transformation or translation of a Source form, including but
 *     not limited to compiled object code, generated documentation,
 *     and conversions to other media types.
 *
 *     "Work" shall mean the work of authorship, whether in Source or
 *     Object form, made available under the License, as indicated by a
 *     copyright notice that is included in or attached to the work
 *     (an example is provided in the Appendix below).
 *
 *     "Derivative Works" shall mean any work, whether in Source or Object
 *     form, that is based on (or derived from) the Work and for which the
 *     editorial revisions, annotations, elaborations, or other modifications
 *     represent, as a whole, an original work of authorship. For the purposes
 *     of this License, Derivative Works shall not include works that remain
 *     separable from, or merely link (or bind by name) to the interfaces of,
 *     the Work and Derivative Works thereof.
 *
 *     "Contribution" shall mean any work of authorship, including
 *     the original version of the Work and any modifications or additions
 *     to that Work or Derivative Works thereof, that is intentionally
 *     submitted to Licensor for inclusion in the Work by the copyright owner
 *     or by an individual or Legal Entity authorized to submit on behalf of
 *     the copyright owner. For the purposes of this definition, "submitted"
 *     means any form of electronic, verbal, or written communication sent
 *     to the Licensor or its representatives, including but not limited to
 *     communication on electronic mailing lists, source code control systems,
 *     and issue tracking systems that are managed by, or on behalf of, the
 *     Licensor for the purpose of discussing and improving the Work, but
 *     excluding communication that is conspicuously marked or otherwise
 *     designated in writing by the copyright owner as "Not a Contribution."
 *
 *     "Contributor" shall mean Licensor and any individual or Legal Entity
 *     on behalf of whom a Contribution has been received by Licensor and
 *     subsequently incorporated within the Work.
 *
 *  2. Grant of Copyright License. Subject to the terms and conditions of
 *     this License, each Contributor hereby grants to You a perpetual,
 *     worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *     copyright license to reproduce, prepare Derivative Works of,
 *     publicly display, publicly perform, sublicense, and distribute the
 *     Work and such Derivative Works in Source or Object form.
 *
 *  3. Grant of Patent License. Subject to the terms and conditions of
 *     this License, each Contributor hereby grants to You a perpetual,
 *     worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *     (except as stated in this section) patent license to make, have made,
 *     use, offer to sell, sell, import, and otherwise transfer the Work,
 *     where such license applies only to those patent claims licensable
 *     by such Contributor that are necessarily infringed by their
 *     Contribution(s) alone or by combination of their Contribution(s)
 *     with the Work to which such Contribution(s) was submitted. If You
 *     institute patent litigation against any entity (including a
 *     cross-claim or counterclaim in a lawsuit) alleging that the Work
 *     or a Contribution incorporated within the Work constitutes direct
 *     or contributory patent infringement, then any patent licenses
 *     granted to You under this License for that Work shall terminate
 *     as of the date such litigation is filed.
 *
 *  4. Redistribution. You may reproduce and distribute copies of the
 *     Work or Derivative Works thereof in any medium, with or without
 *     modifications, and in Source or Object form, provided that You
 *     meet the following conditions:
 *
 *     (a) You must give any other recipients of the Work or
 *         Derivative Works a copy of this License; and
 *
 *     (b) You must cause any modified files to carry prominent notices
 *         stating that You changed the files; and
 *
 *     (c) You must retain, in the Source form of any Derivative Works
 *         that You distribute, all copyright, patent, trademark, and
 *         attribution notices from the Source form of the Work,
 *         excluding those notices that do not pertain to any part of
 *         the Derivative Works; and
 *
 *     (d) If the Work includes a "NOTICE" text file as part of its
 *         distribution, then any Derivative Works that You distribute must
 *         include a readable copy of the attribution notices contained
 *         within such NOTICE file, excluding those notices that do not
 *         pertain to any part of the Derivative Works, in at least one
 *         of the following places: within a NOTICE text file distributed
 *         as part of the Derivative Works; within the Source form or
 *         documentation, if provided along with the Derivative Works; or,
 *         within a display generated by the Derivative Works, if and
 *         wherever such third-party notices normally appear. The contents
 *         of the NOTICE file are for informational purposes only and
 *         do not modify the License. You may add Your own attribution
 *         notices within Derivative Works that You distribute, alongside
 *         or as an addendum to the NOTICE text from the Work, provided
 *         that such additional attribution notices cannot be construed
 *         as modifying the License.
 *
 *     You may add Your own copyright statement to Your modifications and
 *     may provide additional or different license terms and conditions
 *     for use, reproduction, or distribution of Your modifications, or
 *     for any such Derivative Works as a whole, provided Your use,
 *     reproduction, and distribution of the Work otherwise complies with
 *     the conditions stated in this License.
 *
 *  5. Submission of Contributions. Unless You explicitly state otherwise,
 *     any Contribution intentionally submitted for inclusion in the Work
 *     by You to the Licensor shall be under the terms and conditions of
 *     this License, without any additional terms or conditions.
 *     Notwithstanding the above, nothing herein shall supersede or modify
 *     the terms of any separate license agreement you may have executed
 *     with Licensor regarding such Contributions.
 *
 *  6. Trademarks. This License does not grant permission to use the trade
 *     names, trademarks, service marks, or product names of the Licensor,
 *     except as required for reasonable and customary use in describing the
 *     origin of the Work and reproducing the content of the NOTICE file.
 *
 *  7. Disclaimer of Warranty. Unless required by applicable law or
 *     agreed to in writing, Licensor provides the Work (and each
 *     Contributor provides its Contributions) on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *     implied, including, without limitation, any warranties or conditions
 *     of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *     PARTICULAR PURPOSE. You are solely responsible for determining the
 *     appropriateness of using or redistributing the Work and assume any
 *     risks associated with Your exercise of permissions under this License.
 *
 *  8. Limitation of Liability. In no event and under no legal theory,
 *     whether in tort (including negligence), contract, or otherwise,
 *     unless required by applicable law (such as deliberate and grossly
 *     negligent acts) or agreed to in writing, shall any Contributor be
 *     liable to You for damages, including any direct, indirect, special,
 *     incidental, or consequential damages of any character arising as a
 *     result of this License or out of the use or inability to use the
 *     Work (including but not limited to damages for loss of goodwill,
 *     work stoppage, computer failure or malfunction, or any and all
 *     other commercial damages or losses), even if such Contributor
 *     has been advised of the possibility of such damages.
 *
 *  9. Accepting Warranty or Additional Liability. While redistributing
 *     the Work or Derivative Works thereof, You may choose to offer,
 *     and charge a fee for, acceptance of support, warranty, indemnity,
 *     or other liability obligations and/or rights consistent with this
 *     License. However, in accepting such obligations, You may act only
 *     on Your own behalf and on Your sole responsibility, not on behalf
 *     of any other Contributor, and only if You agree to indemnify,
 *     defend, and hold each Contributor harmless for any liability
 *     incurred by, or claims asserted against, such Contributor by reason
 *     of your accepting any such warranty or additional liability.
 *
 *  END OF TERMS AND CONDITIONS
 *
 *  APPENDIX: How to apply the Apache License to your work.
 *
 *     To apply the Apache License to your work, attach the following
 *     boilerplate notice, with the fields enclosed by brackets "[]"
 *     replaced with your own identifying information. (Don't include
 *     the brackets!)  The text should be enclosed in the appropriate
 *     comment syntax for the file format. We also recommend that a
 *     file or class name and description of purpose be included on the
 *     same "printed page" as the copyright notice for easier
 *     identification within third-party archives.
 *
 *  Copyright [yyyy] [name of copyright owner]
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
*/

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <jansson.h>
#include <time.h>
#include <ctype.h>
#include <mysql.h>
#include "mysql/mysqld_error.h"
#include "mysql/errmsg.h"

#include <math.h>

// Re-alert time in minutes for log alerts such as UDP flood, etc
#define MYSQL_MAX_CONNECTIONS_TRIES 10
#define DEFAULT_LOG_FILENAME "/var/log/alerts"

int log_it(const char * str, const char * buffer, const char * failure_message);

// apt-get install libjansson-dev zlib1g-dev libmysqld-dev -y
// gcc $(mysql_config --cflags) -DMAIL_CMD=\"${MAIL_CMD}\" -DDEFAULT_LOG_REALERT_TIME=${LOG_REALERT_TIME} -DCONF_PATH=\"${GENERIC_ALERTS_CONF_PATH}\" -DMYSQL_ALERT_LEN=${MYSQL_ALERT_LEN} -Wall -fvisibility=hidden -O3 -s -o ${CMD_GENERIC_ALERT} ${CMD_GENERIC_ALERT}.c $(mysql_config --libs) -ljansson -lm
/*
[{
    "message": "AP linksys 00:12:34:56:78:90 chan 36 live 4643772",
    "@version": "1",
    "@timestamp": "2015-10-20T18:55:09.000Z",
    "host": "192.168.1.1",
    "customer": {
      "name": "Test system",
      "location": "Somewhere, CO",
      "branch": "",
      "country": "USA",
      "note": "Beta test",
      "contact": {
        "name": "",
        "email": "myemail@example.com",
        "phone": ""
      }
    },
    "devname": "MY-FW-01",
    "devid": "FGP2009644803294",
    "subtype": "wireless",
    "vd": "root",
    "logdesc": "Rogue AP detected",
    "ssid": "linksys",
    "bssid": "00:12:34:56:78:90",
    "aptype": "0",
    "rate": "54",
    "radioband": "802.11a",
    "channel": "36",
    "action": "rogue-ap-detected",
    "manuf": "CISCO SYSTEMS, INC.",
    "security": "WEP",
    "encryption": "N/A",
    "signal": "-74",
    "noise": "-95",
    "live": "4643772",
    "age": "23",
    "onwire": "no",
    "detectionmethod": "N/A",
    "stamac": "N/A",
    "apscan": "N/A",
    "sndetected": "FP221B3X14006637",
    "radioiddetected": "0",
    "stacount": "0",
    "snclosest": "FP221B3X14006637",
    "radioidclosest": "0",
    "apstatus": "0",
    "syslog_severity_code": 5,
    "syslog_facility_code": 23,
    "syslog_facility": "local7",
    "syslog_severity": "notice",
    "priority": 189,
    "fortigate_logid": 104043563,
    "fortigate_logid_str": "0104043563",
    "loglevel": "notice",
    "log_type": "event",
    "type": "fortinet",
    "alert": "Rogue Access point detected: linksys (BSSID: 00:12:34:56:78:90)"
  }]
*/

struct tm * iso8601_to_struct_tm(const char *time_string)
{
	struct tm ctime;
	struct tm * date;
	long ts;

	if (time_string == NULL || strlen(time_string) == 0) {
		return NULL;
	}

	date = (struct tm*)calloc(1, sizeof(struct tm));

	tzset();

	memset(&ctime, 0, sizeof(struct tm));
	strptime(time_string, "%FT%T%z", &ctime);

	ts = mktime(&ctime) - timezone;
	localtime_r(&ts, date);

	return date;
}

char * _log_filename = NULL;
char * _email_from = NULL;
char * _mysql_login = NULL;
char * _mysql_password = NULL;
char * _mysql_db = NULL;
int _log_realert_time = -1;

char * get_string_value(const char * line, const char * item_name_including_equal)
{
	int item_len, line_len;
	char * ret;
	if (line == NULL || item_name_including_equal == NULL) {
		return NULL;
	}
	line_len = strlen(line);
	item_len = strlen(item_name_including_equal);
	if (item_len == 0 || line_len == 0 || strstr(line, item_name_including_equal) != line) {
		return NULL;
	}
	ret = (char *)calloc(1, line_len - item_len + 1);
	if (item_len == line_len || ret == NULL) {
		if (ret != NULL) free(ret);
		return NULL;
	}
	while (line[line_len - 1] == '\r' || line[line_len - 1] == '\n') {
		--line_len;
	}
	memcpy(ret, line + item_len, line_len - item_len);
	return ret;
}

int get_int_value(const char * line, const char * item_name_including_equal, const int default_val)
{
	int ret;
	char * spos;
	char * string = get_string_value(line, item_name_including_equal);
	if (string == NULL) {
		return default_val;
	}

	for (spos = string; *spos != 0; ++spos) {
		if (!isdigit((*spos))) {
			free(string);
			return default_val;
		}
	}

	ret = atoi(string);
	free(string);
	return ret;
}

/*
LOGFILE=???
EMAIL_FROM=????
LOGIN=???
PASSWORD=???
DB=???
# mins
LOG_REALERT_TIME=??
*/
int get_parameters(const char * path)
{
	if (path == NULL || strlen(path) == 0) {
		return EXIT_FAILURE;
	}

	int character = EOF;
	off_t fsize;
	char * line;
	size_t len = 0;
	FILE * f = fopen(path, "rb");
	if (f == NULL) {
		return EXIT_FAILURE;
	}

	fseek(f, 0L, SEEK_END);
	fsize = ftello(f);
	if (fsize == -1) {
		fclose(f);
		return EXIT_FAILURE;
	}
	rewind(f);

	// Allocate memory for line (enough just in case the whole file is one line long)
	line = (char *)malloc(fsize + 1);
	if (line == NULL) {
		fclose(f);
		return EXIT_FAILURE;
	}

	// Getline change the pointer, why?
	//while((read = getline(&line, &len, f)) != -1) {
	while (1) {
		// Pretty much reimplemented getline due to pointer change issue
		memset(line, 0, fsize + 1);
		for (len = 0; len < fsize; ++len) {
			character = fgetc(f);
			if (character == EOF) {
				break;
			}
			if ((char)character == '\n') {
				break;
			}
			line[len] = (char)character;
		}
		if (len == 0) {
			if (character == EOF) {
				break;
			}
			continue;
		}
		// End of reimplementation

		if (_email_from == NULL) {
			_email_from = get_string_value(line, "EMAIL_FROM=");
			if (_email_from != NULL) {
				continue;
			}
		}
		if (_mysql_login == NULL) {
			_mysql_login = get_string_value(line, "LOGIN=");
			if (_mysql_login != NULL) {
				continue;
			}
		}
		if (_mysql_password == NULL) {
			_mysql_password = get_string_value(line, "PASSWORD=");
			if (_mysql_password != NULL) {
				continue;
			}
		}
		if (_mysql_db == NULL) {
			_mysql_db = get_string_value(line, "DB=");
			if (_mysql_db != NULL) {
				continue;
			}
		}
		if (_log_filename == NULL) {
			_log_filename = get_string_value(line, "LOGFILE=");
			if (_log_filename != NULL) {
				continue;
			}
		}

		if (_log_realert_time == -1) {
			_log_realert_time = get_int_value(line, "LOG_REALERT_TIME=", -1);
		}
	}

	fclose(f);
	free(line);
	if (_mysql_db == NULL || _mysql_password == NULL || _mysql_login == NULL || _email_from == NULL) {
		if (_mysql_db != NULL) free(_mysql_db);
		if (_mysql_password != NULL) free(_mysql_password);
		if (_mysql_login != NULL) free(_mysql_login);
		if (_email_from != NULL) free(_email_from);
		if (_log_filename != NULL) free(_log_filename);
		return EXIT_FAILURE;
	}

	// If no log filename, use default
	if (_log_filename == NULL) {
		_log_filename = calloc(1, strlen(DEFAULT_LOG_FILENAME) + 1);
		if (_log_filename == NULL) {
			if (_mysql_db != NULL) free(_mysql_db);
			if (_mysql_password != NULL) free(_mysql_password);
			if (_mysql_login != NULL) free(_mysql_login);
			if (_email_from != NULL) free(_email_from);
			return EXIT_FAILURE;
		}

		strncpy(_log_filename, DEFAULT_LOG_FILENAME, strlen(DEFAULT_LOG_FILENAME));
	}

	// If still -1, use default value
	if (_log_realert_time == -1) {
		_log_realert_time = DEFAULT_LOG_REALERT_TIME;
	}

	return EXIT_SUCCESS;
}

// Returns -1 if failed
// Returns 1 if exists
// Returns 0 if it does not exists
int does_log_alert_exists(const char * alert, const char * time)
{
	struct tm * date;
	MYSQL *conn;
	//MYSQL_RES *res;
	MYSQL_STMT *stmt;
	MYSQL_TIME ts;
	MYSQL_BIND bind[2], bind_search[1];
	unsigned long len;
	int tries, ret, temp_ret;
	char * alert_cp;
	char * search_query;
	const char * insert_query = "INSERT INTO alerts(time, alert) VALUES (?,?)";
	ret = -1;

	if (alert == NULL || time == NULL || strlen(alert) == 0 || strlen(time) == 0) {
		if (alert == NULL || strlen(alert) == 0) {
			log_it("Empty alert", NULL, NULL);
		} else if (time == NULL || strlen(time) == 0) {
			log_it("Empty time", NULL, NULL);
		}
		return -1;
	}

	// Parse date
	date = iso8601_to_struct_tm(time);
	if (date == NULL) {
		alert_cp = (char *)calloc(1, 100 + strlen(time));
		if (alert_cp == NULL) {
			log_it("Failed parsing date - Failed to allocate memory", NULL, NULL);
		} else {
			sprintf(alert_cp, "Failed parsing date <%s>", time);
			log_it(alert_cp, NULL, NULL);
			free(alert_cp);
		}
		return -1;
	}

	conn = NULL;
	for (tries = 0; tries < MYSQL_MAX_CONNECTIONS_TRIES; ++tries)
	{
		conn = mysql_init(NULL);
		if ( mysql_real_connect(conn, "localhost", _mysql_login, _mysql_password, _mysql_db, 0, NULL, 0) != NULL) {
			break;
		}

		mysql_close(conn);
		conn = NULL;

		sleep(1);
	}

	if (tries == MYSQL_MAX_CONNECTIONS_TRIES) {
		free(date);
		log_it(mysql_error(conn), NULL, NULL);
		if (conn != NULL) mysql_close(conn);
		return -1;
	}

	stmt = mysql_stmt_init(conn);
	if (!stmt)
	{
		free(date);
		mysql_stmt_close(stmt);
		mysql_close(conn);
		log_it("mysql_stmt_init(), out of memory\n", NULL, NULL);
		return -1;
	}

#define SEARCH_QUERY_FORMAT "SELECT * from (SELECT alert, time, TIMESTAMPDIFF(MINUTE, time, '%04d-%02d-%02d %02d:%02d:%02d') as time_diff FROM alerts WHERE alert = ?) a WHERE ABS(time_diff) < %ld ORDER BY ABS(time_diff) LIMIT 1"
	search_query = (char *)calloc(1, strlen(SEARCH_QUERY_FORMAT) + (long int)log10(_log_realert_time) + 1 + 1);
	if (search_query == NULL) {
		free(date);
		mysql_close(conn);
		log_it("Failed to allocate memory for search query.\n", NULL, NULL);
		return -1;
	}
	sprintf(search_query, SEARCH_QUERY_FORMAT,
		date->tm_year + 1900, date->tm_mon + 1, date->tm_mday,
		date->tm_hour, date->tm_min, date->tm_sec,
		(long int)_log_realert_time);
#undef SEARCH_QUERY_FORMAT

	if (mysql_stmt_prepare(stmt, search_query, strlen(search_query)))
	{
		free(date);
		log_it(mysql_stmt_error(stmt), NULL, NULL);
		mysql_stmt_close(stmt);
		mysql_close(conn);
		return -1;
	}

	// Alert parameter
	len = strlen(alert);
#ifndef MYSQL_ALERT_LEN
	#define MYSQL_ALERT_LEN 255
#endif
	if (len >= MYSQL_ALERT_LEN) {
		len = MYSQL_ALERT_LEN;
	}
	alert_cp = (char *)calloc(1, len + 1);
	if (alert_cp == NULL) {
		fprintf(stderr, "Failed to allocate memory for search query.\n");
		free(date);
		mysql_stmt_close(stmt);
		mysql_close(conn);
		return -1;
	}
	memcpy(alert_cp, alert, len);
	alert_cp[len] = '\0';


	// Make sure all bind stuff is cleared (and initialized)
	memset(bind_search, 0, sizeof(bind_search));

	bind_search[0].buffer_type = MYSQL_TYPE_STRING;
	bind_search[0].buffer = (char *)alert_cp;
	bind_search[0].buffer_length = len + 1;
	bind_search[0].is_null = 0;
	bind_search[0].length = &len;

	if (mysql_stmt_bind_param(stmt, bind_search)) {
		free(alert_cp);
		free(date);
		mysql_stmt_close(stmt);
		log_it(mysql_error(conn), NULL, NULL);
		mysql_close(conn);
		return -1;
	}

	temp_ret = mysql_stmt_execute(stmt);

	if (temp_ret) {
		free(alert_cp);
		mysql_stmt_close(stmt);
		free(date);
		log_it(mysql_error(conn), NULL, NULL);
		mysql_close(conn);
		return -1;
	}

	// Get amount of rows
	temp_ret = mysql_stmt_fetch(stmt);
	mysql_stmt_close(stmt);
	if (temp_ret == 1 || temp_ret == MYSQL_DATA_TRUNCATED) {
		free(alert_cp);
		free(date);
		log_it(mysql_error(conn), NULL, NULL);
		mysql_close(conn);
		return -1;
	}

	// https://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-fetch.html
	ret = (temp_ret == 0) ? 1 : 0;

	// If it already exists, do not add to DB (doing so could prevent alerting forever if the time between alerts is right below re-alert time)
	if (ret != 1) {
		// Insert record
		stmt = mysql_stmt_init(conn);
		if (!stmt)
		{
			fprintf(stderr, " mysql_stmt_init(), out of memory\n");
			free(date);
			free(alert_cp);
			mysql_close(conn);
			log_it("mysql_stmt_init(), out of memory\n", NULL, NULL);
			return -1;
		}

		if (mysql_stmt_prepare(stmt, insert_query, strlen(insert_query)))
		{
			fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
			free(date);
			free(alert_cp);
			log_it(mysql_stmt_error(stmt), NULL, NULL);
			mysql_stmt_close(stmt);
			mysql_close(conn);
			return -1;
		}

		// Make sure all bind stuff is cleared (and initialized)
		memset(bind, 0, sizeof(bind));

		// Date parameter
		bind[0].buffer_type = MYSQL_TYPE_DATETIME;
		bind[0].buffer= (char *)&ts;
		bind[0].is_null= 0;
		bind[0].length= 0;

		ts.year= date->tm_year + 1900;
		ts.month= date->tm_mon + 1;
		ts.day= date->tm_mday;

		ts.hour= date->tm_hour;
		ts.minute= date->tm_min;
		ts.second= date->tm_sec;
		ts.second_part = 0;
		ts.neg = 0;

		bind[1].buffer_type = MYSQL_TYPE_STRING;
		bind[1].buffer = (char *)alert_cp;
		bind[1].buffer_length = len + 1;
		bind[1].is_null = 0;
		bind[1].length = &len;

		if (mysql_stmt_bind_param(stmt, bind)) {
			free(alert_cp);
			free(date);
			mysql_stmt_close(stmt);
			log_it(mysql_error(conn), NULL, NULL);
			mysql_close(conn);
			return -1;
		}

		temp_ret = mysql_stmt_execute(stmt);

		if (temp_ret && mysql_errno(conn) != ER_DUP_ENTRY) { // 1062
			mysql_stmt_close(stmt);
			free(date);
			log_it(mysql_error(conn), NULL, NULL);
			mysql_close(conn);
			return -1;
		}

		mysql_stmt_close(stmt);
	}

	free(alert_cp);
	free(date);
	mysql_close(conn);

	return ret;
}

char * get_string_item(json_t * array_item, const char * name)
{
	json_t * item;
	const char * item_str;
	char * ret = NULL;
	if (array_item == NULL || !json_is_object(array_item) || name == NULL || strlen(name) == 0) {
			return NULL;
	}
	item = json_object_get(array_item, name);
	if (item == NULL) {
			return NULL;
	}
	item_str = json_string_value(item);
	if (item_str == NULL || strlen(item_str) == 0) {
			return NULL;
	}
	ret = (char *)calloc(1, strlen(item_str) + 1);
	if (ret == NULL) {
		return NULL;
	}
	strcpy(ret, item_str);
	return ret;
}

json_int_t get_int_item(json_t * array_item, const char * name, int value_if_invalid)
{
	json_t * item;
	if (array_item == NULL || !json_is_object(array_item) || name == NULL || strlen(name) == 0) {
		return value_if_invalid;
	}
	item = json_object_get(array_item, name);
	if (item == NULL) {
		return value_if_invalid;
	}
	return json_integer_value(item);
}

int send_email(const char * from, const char * to, const char * subject, const char * content)
{
	int ret;
	char * email_cmd = (char *)calloc(1,1024*1024);

	if (email_cmd == NULL || from == NULL || to == NULL || subject == NULL || strlen(to) < 6 || strlen(from) < 6 || strchr(to, (int)'@') == NULL || strchr(from, (int)'@') == NULL || strlen(subject) == 0) {
		return 1;
	}
	if (content == NULL || strlen(content) == 0) {
		sprintf(email_cmd, "%s -aFrom:%s -s '%s' %s", MAIL_CMD, from, subject, to);
	} else {
		sprintf(email_cmd, "echo '%s\n\n' | %s -aFrom:%s -s '%s' %s", content, MAIL_CMD, from, subject, to);
	}

	ret = system(email_cmd);
	free(email_cmd);
	return ret;
}

int send_email_alert(const char * to, char * alert)
{
	int ret;

	if (alert == NULL || to == NULL || strlen(to) < 6 || strlen(alert) == 0) {
		return 1;
	}

	ret = send_email(_email_from, to, "[Netforce Defender] Log alert", alert);

	return ret;
}

int send_email_snort(const char * datetime, const char * email, const char * message, const char * source_ip, const int src_port, const char * destination_ip, const int dst_port, const char * proto, const int priority)
{
	int ret;
	char * subject, * content;

	if (email == NULL || strlen(email) < 6) {
		return 1;
	}

	subject = (char *)calloc(1, 1024);
	if (subject == NULL) {
		printf("Failed to allocate memory for email subject\n");
		return 1;
	}
	content = (char *)calloc(1, 1024*1024);
	if (content == NULL) {
		printf("Failed to allocate memory for email content\n");
		free(subject);
		return 1;
	}

	sprintf(subject, "[Netforce Defender] %salert", (priority == 1) ? "High priority " : (priority == 2) ? "Medium priority " : (priority == 3) ? "Low priority " : "");
	sprintf(content, "At least one event (%s) has been detected around %s.\nSource IP: %s:%d\nDestination IP: %s:%d\nProtocol: %s\nPlease check the sensor web interface for details.",
					  message, datetime, source_ip, src_port, destination_ip, dst_port, proto);

	ret = send_email(_email_from, email, subject, content);

	free(content);
	free(subject);
	return ret;
}

char ** split_emails(const char * emails)
{
	char ** ret;
	int i, id, pos;

	if (emails == NULL || strlen(emails) == 0) {
		return NULL;
	}

	// Skip space
	for (i = 0; emails[i] == ' ' || emails[i] == ';' || emails[i] == ','; ++i) {
		if (emails[i] == '\0') {
			return NULL;
		}
	}

	// Start parsing email
	ret = (char **)calloc(1, sizeof(char *));
	*ret = (char *)calloc(1, strlen(emails) + 1);

	for (id = pos = 0; emails[i] != 0; ++i) {
		// Check for separator
		if (emails[i] != ' ' && emails[i] != ',' && emails[i] != ';') {
			ret[id][pos++] = emails[i];
			continue;
		}

		// Next item
		for (++id; emails[i] != 0 && (emails[i] == ' ' || emails[i] == ',' || emails[i] == ';'); ++i);
		if (emails[i] == 0) {
			--id;
			break;
		}
		--i; // Avoid skipping first char of the next item
		pos = 0;
		ret = (char **)realloc(ret, (id + 1) * sizeof(char *));
		ret[id] = (char *)calloc(1, strlen(emails) + 1);
	}

	// Cleanup
	if (ret[id][0] != 0) {
		ret = (char **)realloc(ret, (id + 2) * sizeof(char *));
		ret[id + 1] = NULL;
	} else {
		free(ret[id]);
		if (id == 0) {
			free(ret);
			ret = NULL;
		} else {
			ret[id] = NULL;
		}
	}
	return ret;
}

char ** get_customer_emails(json_t * array_item)
{
	json_t * customer, *contact;
	char * emails;
	char ** ret;

	if (array_item == NULL || !json_is_object(array_item)) {
			return NULL;
	}
	customer = json_object_get(array_item, "customer");
	if (customer == NULL) {
			return NULL;
	}
	contact = json_object_get(customer, "contact");
	if (contact == NULL) {
			return NULL;
	}
	emails = get_string_item(contact, "email");
	if (emails == NULL) {
		return NULL;
	}

	// Parse emails
	ret = split_emails(emails);
	free(emails);
	return ret;
}

int log_it(const char * str, const char * buffer, const char * failure_message)
{
	time_t rawtime;
	int ret;
	char * time_str;
	FILE * f = fopen(_log_filename, "a");

	if (f == NULL || str == NULL || strlen(str) == 0) return 1;

	rawtime = time(NULL);
	time_str = (char *)calloc(1, strlen(ctime(&rawtime)) + 1);
	strcpy(time_str, ctime(&rawtime));
	// Remove newline at the end
	time_str[strlen(time_str) - 1] = '\0';

	if (buffer != NULL && strlen(buffer) > 0) {
		ret = fprintf(f, "%s - Alerting - %s - Buffer (length: %ld): %s%s", time_str, str,
			(buffer == NULL) ? 0 : strlen(buffer),
			buffer, (buffer[strlen(buffer) -1 ] == '\n') ? "" : "\n");
	} else {
		ret = fprintf(f, "%s - Alerting - %s%s", time_str, str, (str[strlen(str) -1 ] == '\n') ? "" : "\n");
	}
	
	free(time_str);

	if (ret <= 0) {
		if (failure_message != NULL) printf("%s\n", failure_message);
		return 1;
	}
	fflush(f);
	fclose(f);
	return 0;
}

int log_it_alert(const char * datetime, const char * to, const char * alert, const char * buffer, int email_return_value, int log_exists)
{
	int ret;
	char * log_str = (char *)calloc(1, 65535);
	if (log_str == NULL) {
		printf("Failed to allocate memory for log string.\n");
		return 1;
	}

	sprintf(log_str, "Sent log alert email (%s - %s) to <%s> (from %s) for a <%s> event (happened at %s)",
		(email_return_value == 0) ? "success" : (email_return_value == -1) ? "not sent" : "failure",
		(log_exists == -1) ? "failure to check for alert/log existence" : (log_exists == 0) ? "alert has not been sent yet" : "alert has already been sent earlier",
		to, _email_from, alert, datetime);
	ret = log_it(log_str, buffer, "Failed to log a log alert.");
	free(log_str);

	return ret;
}

int log_it_snort(const char * datetime, const char * email, const char * message, const char * source_ip, const int src_port, const char * destination_ip, const int dst_port, const char * proto, const int priority, const char * buffer, int email_return_value)
{
	int ret;
	char * log_str = (char *)calloc(1, 65535);

	sprintf(log_str, "Sent snort alert email (%s) to <%s> (from %s) for a <%s> event (happened at %s, priority: %d) from IP <%s:%d> to IP <%s:%d> (Protocol: %s)",
			(email_return_value != 0) ? "failure" : "success", email, _email_from, message, datetime, priority, source_ip, src_port, destination_ip, dst_port, proto);
	ret = log_it(log_str, buffer, "Failed to log a snort alert.");
	free(log_str);

	return ret;
}

int file_exists(const char * path)
{
	FILE * f;

	if (path == NULL || strlen(path) == 0) {
		return 0;
	}

	f = fopen(path, "r");
	if (f == NULL) {
		return 0;
	}
	fclose(f);

	return 1;
}

int main()
{
	char * buffer;
	char *source_ip, *destination_ip, *message, *datetime, *protocol, * alert, *temp;
	char ** customer_emails;
	int i, pos, ret, src_port, dst_port, priority, log_exists;
	json_t * json_root, *data;
	json_error_t json_error;
	buffer = (char *) calloc(1, 1024*1024);
	pos = 0;
	while (read(STDIN_FILENO, buffer+pos, 1) > 0) {
			++pos;
	}

	if (file_exists(MAIL_CMD) == 0) {
		free(buffer);
		log_it("Mail command does not exists", NULL, "Failed");
		return EXIT_FAILURE;
	}

	json_root = json_loads(buffer, 0, &json_error);
	// Do not free buffer now, json structure is using it. Free it at the end.

//	  // Temporary
//	  json_root = json_loads(json_text, 0, &json_error);

	if (!json_root) {
			printf("Failed loading JSON\n");
			free(buffer);
			return EXIT_FAILURE;
	}
	if (!json_is_array(json_root)) {
			json_decref(json_root);
			free(buffer);
			printf("Not an array");
			return EXIT_FAILURE;
	}

	// Get credentials from file
	if (get_parameters(CONF_PATH) == EXIT_FAILURE) {
		temp = (char *)calloc(1, 100 + strlen(CONF_PATH));
		if (temp == NULL) {
			log_it("Failed parsing parameters file - Failed to allocate memory", NULL, NULL);
		} else {
			sprintf(temp, "Failed parsing parameters file <%s>", CONF_PATH);
			log_it(temp, NULL, NULL);
			free(temp);
		}
		json_decref(json_root);
		free(buffer);
		return EXIT_FAILURE;
	}

	for (pos = 0; pos < json_array_size(json_root); ++pos)
	{
		data = json_array_get(json_root, pos);
		if (json_is_object(data)) {
			// Get the different parameters
			datetime = get_string_item(data, "@timestamp");
			customer_emails = get_customer_emails(data);
			alert = get_string_item(data, "alert");
			if (alert != NULL && strlen(alert) > 0) {
				// Regular log alert
				ret = -1;
				log_exists = does_log_alert_exists(alert, datetime);
				for (i = 0; customer_emails[i] != NULL; ++i) {
					if (log_exists == 0) {
						ret = send_email_alert(customer_emails[i], alert);
					}
					log_it_alert(datetime, customer_emails[i], alert, buffer, ret, log_exists);
				}
			} else {
				// Snort alert
				message = get_string_item(data, "msg");
				if (message == NULL || strlen(message) == 0) {
					message = get_string_item(data, "classification");
				}
				source_ip = get_string_item(data, "srcip");
				destination_ip = get_string_item(data, "dstip");
				protocol = get_string_item(data, "protocol");
				src_port = get_int_item(data, "srcport", 0);
				dst_port = get_int_item(data, "dstport", 0);
				priority = get_int_item(data, "priority", 0);

				// Send email and log it
				for (i = 0; customer_emails[i] != NULL; ++i) {
					ret = send_email_snort(datetime, customer_emails[i], message, source_ip, src_port, destination_ip, dst_port, protocol, priority);
					log_it_snort(datetime, customer_emails[i], message, source_ip, src_port, destination_ip, dst_port, protocol, priority, buffer, ret);
				}

				// Free all the stuff
				if (message != NULL) free(message);
				if (source_ip != NULL) free(source_ip);
				if (destination_ip != NULL) free(destination_ip);
				if (protocol != NULL) free(protocol);
			}
			// Free all the stuff
			if (datetime != NULL) free(datetime);
			if (customer_emails != NULL) {
				for (i = 0; customer_emails[i] != NULL; ++i) {
					free(customer_emails[i]);
				}
				free(customer_emails);
			}
			if (alert != NULL) free(alert);

		}
		//json_decref(data);
	}

	json_decref(json_root);
	free(buffer);

	if (_mysql_db != NULL) free(_mysql_db);
	if (_mysql_password != NULL) free(_mysql_password);
	if (_mysql_login != NULL) free(_mysql_login);
	if (_email_from != NULL) free(_email_from);
	if (_log_filename != NULL) free(_log_filename);

	return EXIT_SUCCESS;
}