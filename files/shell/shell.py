#!/usr/bin/env python
#   Copyright 2016 MainNerve LLC
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#
#                                 Apache License
#                           Version 2.0, January 2004
#                        http://www.apache.org/licenses/
#
#   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
#
#   1. Definitions.
#
#      "License" shall mean the terms and conditions for use, reproduction,
#      and distribution as defined by Sections 1 through 9 of this document.
#
#      "Licensor" shall mean the copyright owner or entity authorized by
#      the copyright owner that is granting the License.
#
#      "Legal Entity" shall mean the union of the acting entity and all
#      other entities that control, are controlled by, or are under common
#      control with that entity. For the purposes of this definition,
#      "control" means (i) the power, direct or indirect, to cause the
#      direction or management of such entity, whether by contract or
#      otherwise, or (ii) ownership of fifty percent (50%) or more of the
#      outstanding shares, or (iii) beneficial ownership of such entity.
#
#      "You" (or "Your") shall mean an individual or Legal Entity
#      exercising permissions granted by this License.
#
#      "Source" form shall mean the preferred form for making modifications,
#      including but not limited to software source code, documentation
#      source, and configuration files.
#
#      "Object" form shall mean any form resulting from mechanical
#      transformation or translation of a Source form, including but
#      not limited to compiled object code, generated documentation,
#      and conversions to other media types.
#
#      "Work" shall mean the work of authorship, whether in Source or
#      Object form, made available under the License, as indicated by a
#      copyright notice that is included in or attached to the work
#      (an example is provided in the Appendix below).
#
#      "Derivative Works" shall mean any work, whether in Source or Object
#      form, that is based on (or derived from) the Work and for which the
#      editorial revisions, annotations, elaborations, or other modifications
#      represent, as a whole, an original work of authorship. For the purposes
#      of this License, Derivative Works shall not include works that remain
#      separable from, or merely link (or bind by name) to the interfaces of,
#      the Work and Derivative Works thereof.
#
#      "Contribution" shall mean any work of authorship, including
#      the original version of the Work and any modifications or additions
#      to that Work or Derivative Works thereof, that is intentionally
#      submitted to Licensor for inclusion in the Work by the copyright owner
#      or by an individual or Legal Entity authorized to submit on behalf of
#      the copyright owner. For the purposes of this definition, "submitted"
#      means any form of electronic, verbal, or written communication sent
#      to the Licensor or its representatives, including but not limited to
#      communication on electronic mailing lists, source code control systems,
#      and issue tracking systems that are managed by, or on behalf of, the
#      Licensor for the purpose of discussing and improving the Work, but
#      excluding communication that is conspicuously marked or otherwise
#      designated in writing by the copyright owner as "Not a Contribution."
#
#      "Contributor" shall mean Licensor and any individual or Legal Entity
#      on behalf of whom a Contribution has been received by Licensor and
#      subsequently incorporated within the Work.
#
#   2. Grant of Copyright License. Subject to the terms and conditions of
#      this License, each Contributor hereby grants to You a perpetual,
#      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#      copyright license to reproduce, prepare Derivative Works of,
#      publicly display, publicly perform, sublicense, and distribute the
#      Work and such Derivative Works in Source or Object form.
#
#   3. Grant of Patent License. Subject to the terms and conditions of
#      this License, each Contributor hereby grants to You a perpetual,
#      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#      (except as stated in this section) patent license to make, have made,
#      use, offer to sell, sell, import, and otherwise transfer the Work,
#      where such license applies only to those patent claims licensable
#      by such Contributor that are necessarily infringed by their
#      Contribution(s) alone or by combination of their Contribution(s)
#      with the Work to which such Contribution(s) was submitted. If You
#      institute patent litigation against any entity (including a
#      cross-claim or counterclaim in a lawsuit) alleging that the Work
#      or a Contribution incorporated within the Work constitutes direct
#      or contributory patent infringement, then any patent licenses
#      granted to You under this License for that Work shall terminate
#      as of the date such litigation is filed.
#
#   4. Redistribution. You may reproduce and distribute copies of the
#      Work or Derivative Works thereof in any medium, with or without
#      modifications, and in Source or Object form, provided that You
#      meet the following conditions:
#
#      (a) You must give any other recipients of the Work or
#          Derivative Works a copy of this License; and
#
#      (b) You must cause any modified files to carry prominent notices
#          stating that You changed the files; and
#
#      (c) You must retain, in the Source form of any Derivative Works
#          that You distribute, all copyright, patent, trademark, and
#          attribution notices from the Source form of the Work,
#          excluding those notices that do not pertain to any part of
#          the Derivative Works; and
#
#      (d) If the Work includes a "NOTICE" text file as part of its
#          distribution, then any Derivative Works that You distribute must
#          include a readable copy of the attribution notices contained
#          within such NOTICE file, excluding those notices that do not
#          pertain to any part of the Derivative Works, in at least one
#          of the following places: within a NOTICE text file distributed
#          as part of the Derivative Works; within the Source form or
#          documentation, if provided along with the Derivative Works; or,
#          within a display generated by the Derivative Works, if and
#          wherever such third-party notices normally appear. The contents
#          of the NOTICE file are for informational purposes only and
#          do not modify the License. You may add Your own attribution
#          notices within Derivative Works that You distribute, alongside
#          or as an addendum to the NOTICE text from the Work, provided
#          that such additional attribution notices cannot be construed
#          as modifying the License.
#
#      You may add Your own copyright statement to Your modifications and
#      may provide additional or different license terms and conditions
#      for use, reproduction, or distribution of Your modifications, or
#      for any such Derivative Works as a whole, provided Your use,
#      reproduction, and distribution of the Work otherwise complies with
#      the conditions stated in this License.
#
#   5. Submission of Contributions. Unless You explicitly state otherwise,
#      any Contribution intentionally submitted for inclusion in the Work
#      by You to the Licensor shall be under the terms and conditions of
#      this License, without any additional terms or conditions.
#      Notwithstanding the above, nothing herein shall supersede or modify
#      the terms of any separate license agreement you may have executed
#      with Licensor regarding such Contributions.
#
#   6. Trademarks. This License does not grant permission to use the trade
#      names, trademarks, service marks, or product names of the Licensor,
#      except as required for reasonable and customary use in describing the
#      origin of the Work and reproducing the content of the NOTICE file.
#
#   7. Disclaimer of Warranty. Unless required by applicable law or
#      agreed to in writing, Licensor provides the Work (and each
#      Contributor provides its Contributions) on an "AS IS" BASIS,
#      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#      implied, including, without limitation, any warranties or conditions
#      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
#      PARTICULAR PURPOSE. You are solely responsible for determining the
#      appropriateness of using or redistributing the Work and assume any
#      risks associated with Your exercise of permissions under this License.
#
#   8. Limitation of Liability. In no event and under no legal theory,
#      whether in tort (including negligence), contract, or otherwise,
#      unless required by applicable law (such as deliberate and grossly
#      negligent acts) or agreed to in writing, shall any Contributor be
#      liable to You for damages, including any direct, indirect, special,
#      incidental, or consequential damages of any character arising as a
#      result of this License or out of the use or inability to use the
#      Work (including but not limited to damages for loss of goodwill,
#      work stoppage, computer failure or malfunction, or any and all
#      other commercial damages or losses), even if such Contributor
#      has been advised of the possibility of such damages.
#
#   9. Accepting Warranty or Additional Liability. While redistributing
#      the Work or Derivative Works thereof, You may choose to offer,
#      and charge a fee for, acceptance of support, warranty, indemnity,
#      or other liability obligations and/or rights consistent with this
#      License. However, in accepting such obligations, You may act only
#      on Your own behalf and on Your sole responsibility, not on behalf
#      of any other Contributor, and only if You agree to indemnify,
#      defend, and hold each Contributor harmless for any liability
#      incurred by, or claims asserted against, such Contributor by reason
#      of your accepting any such warranty or additional liability.
#
#   END OF TERMS AND CONDITIONS
#
#   APPENDIX: How to apply the Apache License to your work.
#
#      To apply the Apache License to your work, attach the following
#      boilerplate notice, with the fields enclosed by brackets "[]"
#      replaced with your own identifying information. (Don't include
#      the brackets!)  The text should be enclosed in the appropriate
#      comment syntax for the file format. We also recommend that a
#      file or class name and description of purpose be included on the
#      same "printed page" as the copyright notice for easier
#      identification within third-party archives.
#
#   Copyright [yyyy] [name of copyright owner]
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

from __future__ import print_function
import sys, os, subprocess, time, getpass, traceback
# apt-get install python-jsonrpclib
# https://github.com/joshmarshall/jsonrpclib
try:
	import jsonrpclib
except:
	print('jsonrpclib package required. Ubuntu: apt-get install python-jsonrpclib')
	# Python3: python3-dnspython
	sys.exit(1)


# TODO: Clear history from time to time: history.clear

class SmallToken:
	# UUID token
	token = False
	# Time in seconds before expiration
	expireTime = False

level = ''

password_token = False
token_timeout = -1

jsonrpc_server = False

# TODO
# - Signal handling
# - Improve shell errors
# - Handle clearing information with the word 'remove' (such as customer information)
# - Normalize how parameters are displayed (in the document too)
# - Add status of the different services (LS, ES, Kibana, Quagga, etc) and if it's normal (if stopped) - new menu

def is_var_string(var):
	if var == None:
		return False
	try:
		# Python 2
		return isinstance(var, basestring)
	except:
		pass
	# Python 3
	return isinstance(var, str)

def splitCommand(command):
	if not command:
		return [ '', '' ]
	if ' ' in command:
		return command.split(' ', 1)
	return [ command, '' ]

def waitForCommand():
	print(level + '> ', end="")
	line = sys.stdin.readline()    # readline will return "" on EOF
	if line:
		return line.strip()   # * if user just pressed Enter line will be "\n", i.e. still True
	else:
		print('exit')
		return "exit"	  # * user pressed C-D, i.e. stdin has been closed readline call must have returned ""

	# Python 3: input()
	#return raw_input( level + '> ');

def sendPing():
	try:
		if jsonrpc_server.ping(password_token.token) == 'pong':
			return True
	except:
		pass
	return False

def sendWebList():
	try:
		return jsonrpc_server.web_list(password_token.token)
	except:
		return False

def sendWebAddUser(user, password):
	if not user or not password:
		return False
	try:
		return jsonrpc_server.web_adduser(password_token.token, user, password)
	except:
		return False

def sendWebDelUser(user):
	if not user:
		return False
	try:
		return jsonrpc_server.web_deluser(password_token.token, user)
	except:
		return False

def sendWebModifyUser(user, password):
	if not user or not password:
		return False
	try:
		return jsonrpc_server.web_modify_user(password_token.token, user, password)
	except:
		return False

def sendWebRegenNginxCert(subject):
	try:
		return jsonrpc_server.web_regen_nginx_cert(password_token.token, subject)
	except:
		return None

def sendLogListSupportedTypes():
	try:
		return jsonrpc_server.log_list_supported_types(password_token.token)
	except:
		return None

def sendLogListEnabledItems():
	try:
		return jsonrpc_server.log_list_enabled(password_token.token)
	except:
		return None

def sendLogAddItem(log_type, proto, port):
	try:
		return jsonrpc_server.log_add_item(password_token.token, log_type, proto, port)
	except:
		return None

def sendLogRemoveItem(log_type, proto, port):
	try:
		return jsonrpc_server.log_remove_item(password_token.token, log_type, proto, port)
	except:
		return None

def sendLogApplySettings():
	try:
		return jsonrpc_server.log_apply_settings(password_token.token)
	except:
		return None

def sendConnect(login, password):
	global password_token
	global jsonrpc_server
	if login and password:
		try:
			jsonrpc_server = jsonrpclib.Server('http://localhost:8080')
			password_token = jsonrpc_server.login(login, password)
			if password_token == False:
				print("Invalid login or password")
			else:
				print("Connected as " + login)
		except:
			print("Failed to login. Is server up?")
			password_token = False
	return password_token != False

def sendDisconnect():
	global password_token
	if password_token != False:
		try:
			jsonrpc_server.logout(password_token.token)
		except:
			pass
		jsonrpc_server = False
		password_token = False
		return True
	jsonrpc_server = False
	return False

def changeSSHUserPassword(user, new_password):
	if not user or not new_password:
		return False
	success = True
	cmd = ['/usr/bin/passwd', user]
	p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
	p.stdin.write(u'%(p)s\n%(p)s\n' % { 'p': new_password })
	p.stdin.flush()
	# Give `passwd` cmd 2 seconds to finish and kill it otherwise.
	for x in range(0, 10):
		if p.poll() is not None:
			break
		time.sleep(0.2)
	else:
		p.terminate()
		time.sleep(1)
		p.kill()
		success = False
	if p.returncode != 0 or success == False:
		print('Failed to change ' + user + ' password')
		return False
	return True

def sendCIGetSensorName():
	try:
		return jsonrpc_server.customer_info_get_name(password_token.token)
	except:
		return None

def sendCISetSensorName(name):
	try:
		return jsonrpc_server.customer_info_set_name(password_token.token, name)
	except:
		return None

def sendCIGetEmail():
	try:
		return jsonrpc_server.customer_info_get_contact_email(password_token.token)
	except:
		return None

def sendCISetEmail(email):
	try:
		return jsonrpc_server.customer_info_set_contact_email(password_token.token, email)
	except:
		return None

def sendCIGetContactName():
	try:
		return jsonrpc_server.customer_info_get_contact_name(password_token.token)
	except:
		return None

def sendCISetContactName(name):
	try:
		return jsonrpc_server.customer_info_set_contact_name(password_token.token, name)
	except:
		return None

def sendCIGetContactPhone():
	try:
		return jsonrpc_server.customer_info_get_contact_phone(password_token.token)
	except:
		return None

def sendCISetContactPhone(phone):
	try:
		return jsonrpc_server.customer_info_set_contact_phone(password_token.token, phone)
	except:
		return None

def sendCIGetLocation():
	try:
		return jsonrpc_server.customer_info_get_location(password_token.token)
	except:
		return None

def sendCISetLocation(location):
	try:
		return jsonrpc_server.customer_info_set_location(password_token.token, location)
	except:
		return None

def sendCIGetBranch():
	try:
		return jsonrpc_server.customer_info_get_branch(password_token.token)
	except:
		return None

def sendCISetBranch(branch):
	try:
		return jsonrpc_server.customer_info_set_branch(password_token.token, branch)
	except:
		return None

def sendCIGetCountry():
	try:
		return jsonrpc_server.customer_info_get_country(password_token.token)
	except:
		return None

def sendCISetCountry(country):
	try:
		return jsonrpc_server.customer_info_set_country(password_token.token, country)
	except:
		return None

def sendCIGetNote():
	try:
		return jsonrpc_server.customer_info_get_note(password_token.token)
	except:
		return None

def sendCISetNote(note):
	try:
		return jsonrpc_server.customer_info_set_note(password_token.token, note)
	except:
		return None

def print_if_error(value, what):
	if value == None:
		print("Failed " + what)
		return True
	elif value == False:
		print("Log out then log in then try again")
		return True
	return False

# Network settings

def sendNetworkGetInterface(interface):
	try:
		return jsonrpc_server.network_get_interface(password_token.token, interface)
	except:
		return None

def sendNetworkSetInterfaceDisable(interface):
	try:
		return jsonrpc_server.network_set_interface_disable(password_token.token, interface)
	except:
		return None

def sendNetworkSetInterfaceStatic(interface, ip, netmask, gateway):
	try:
		return jsonrpc_server.network_set_interface_static(password_token.token, interface, ip, netmask, gateway)
	except:
		return None

def sendNetworkSetInterfaceDHCP(interface):
	try:
		return jsonrpc_server.network_set_interface_dhcp(password_token.token, interface)
	except:
		return None

def sendNetworkSetInterfaceIDS(interface):
	try:
		return jsonrpc_server.network_set_interface_ids(password_token.token, interface)
	except:
		return None

def sendNetworkGetDNS():
	try:
		return jsonrpc_server.network_get_dns(password_token.token)
	except:
		return None

def sendNetworkSetDNS(dns):
	try:
		return jsonrpc_server.network_set_dns(password_token.token, dns)
	except:
		return None

def sendNetworkNSLookup(target, server):
	try:
		return jsonrpc_server.network_do_nslookup(password_token.token, target, server)
	except:
		return None

def sendNetworkWhois(domain):
	try:
		return jsonrpc_server.network_do_whois(password_token.token, domain)
	except:
		return None

# System

def sendSystemStatus(item):
	try:
		return jsonrpc_server.system_status(password_token.token, item)
	except:
		return None

def sendSystemStartService(item):
	try:
		return jsonrpc_server.system_start_service(password_token.token, item)
	except:
		return None

def sendSystemStopService(item):
	try:
		return jsonrpc_server.system_stop_service(password_token.token, item)
	except:
		return None

def sendSystemRestartService(item):
	try:
		return jsonrpc_server.system_restart_service(password_token.token, item)
	except:
		return None

def sendSystemReboot():
	try:
		return jsonrpc_server.reboot(password_token.token)
	except:
		print("Failed to reboot system")
		return False

def sendSystemShutdown():
	try:
		return jsonrpc_server.shutdown(password_token.token)
	except:
		print("Failed to shutdown system")
		return False

def sendSystemEnableService(service):
	try:
		return jsonrpc_server.system_enable_service(password_token.token, service)
	except:
		return None

def sendSystemDisableService(service):
	try:
		return jsonrpc_server.system_disable_service(password_token.token, service)
	except:
		return None

def sendSystemRegenSSHKeys():
	try:
		return jsonrpc_server.system_regen_ssh_keys(password_token.token)
	except:
		return None

def sendSystemGetDiskUsage():
	try:
		return jsonrpc_server.system_get_disk_usage(password_token.token)
	except:
		return None

def sendSystemGetMemoryUsage():
	try:
		return jsonrpc_server.system_get_memory_usage(password_token.token)
	except:
		return None

def sendSystemGetUptime():
	try:
		return jsonrpc_server.system_get_uptime(password_token.token)
	except:
		return None

def sendSystemGetProcessList(modifier):
	try:
		return jsonrpc_server.system_get_ps(password_token.token, modifier)
	except:
		return None

def sendSystemGetNetstat(option):
	try:
		return jsonrpc_server.system_get_netstat(password_token.token, option)
	except:
		return None

########################## Parse commands

def parseWebCommand(command, parameters):
	if password_token == False:
		return False
	elif command == '?':
		print('list                          List all users')
		print('add <user> <password>         Add new user')
		print('delete <user>                 Delete user')
		print('change <user> <password>      Change user password')
		print('regen_nginx_cert [subject]    Regenerate Nginx certificate with a specific subject')
		sendPing()
		return True
	elif command == 'list':
		if parameters:
			print('No parameters required for list, ignoring')
		user_list = sendWebList()
		if user_list == False:
			print("Failed obtaining user list")
			return True
		for user in user_list:
			print(user)
		return True
	elif command == 'add':
		if not parameters:
			print('Missing parameters: user and password')
			return True
		up = splitCommand(parameters)
		if not up[0] or not up[1]:
			print('Missing parameters: user and password')
			return True
		if sendWebAddUser(up[0], up[1]) == False:
			print("Failed adding user")
		return True
	elif command == 'delete' or command == 'del':
		if not parameters:
			print("Missing parameter: user")
		elif sendWebDelUser(parameters) == False:
			print("Failed deleting <" + user + ">")
		return True
	elif command == 'change':
		if not parameters:
			print('Missing parameters: user and password')
			return True
		up = splitCommand(parameters)
		if not up[0] or not up[1]:
			print('Missing parameters: user and password')
			return True
		if sendWebModifyUser(up[0], up[1]) == False:
			print("Failed changing password for <" + up[0] + ">")
		return True
	elif command == 'regen_nginx_cert':
		ret = sendWebRegenNginxCert(parameters)
		if ret == None:
			print("Issue regenerating Nginx certificate.")
		elif ret == False:
			print("Failed regenerating Nginx certificate.")
		return True
	return False

def parseNetworkCommand(command, parameters):
	if password_token == False:
		return False
	elif command == '?':
		print('list                          List all interfaces')
		print('show <interface>              Display settings of an interface')
		print('disable <interface>           Disable interface')
		print('static <interface> <IP> <netmask> <gateway>')
		print('                              Use a static IP address for the interface <name>')
		print('dhcp <interface>              Set interface to DHCP')
		print('ids <interface>               Set interface to IDS mode')
		print('dns <IP>                      Display or set DNS (use "remove" instead of "IP" to remove it)')
		print('ping <target> [count]         Ping target for [count] times')
		print('traceroute <target> [hops]    Traceroute target (limit to a max # of hops; default: 30)')
		print('nslookup <target> [server]    Query DNS for target. Default server: /etc/resolv.conf')
		print('whois <domain>                Whois domain')
		sendPing()
		return True
	elif command == 'whois':
		if not parameters:
			print('Missing parameter: domain')
			return True
		ret = sendNetworkWhois(parameters)
		if not print_if_error(ret, "to get whois information"):
			if is_var_string(ret):
				print(ret)
			else:
				print(ret)
		return True
	elif command == 'ping':
		sendPing()
		if not parameters:
			print("Missing target")
			return True
		target = parameters
		count = 4
		if ' ' in parameters:
			param_split = splitCommand(parameters)
			target = param_split[0]
			try:
				count = int(param_split[1])
			except:
				print("Failed parsing ping count")
				return True
		# Reason for not using server version: Need live view of it
		subprocess.call(['/bin/ping', target, '-c', str(count)])

		return True
	elif command == 'traceroute':
		sendPing()
		if not parameters:
			print("Missing target")
			return True
		target = parameters
		hops = 30
		if ' ' in parameters:
			param_split = splitCommand(parameters)
			target = param_split[0]
			try:
				hops = int(param_split[1])
			except:
				print("Failed parsing max # of hops")
				return True
		# Reason for not using server version: Need live view of it
		subprocess.call(['/usr/sbin/traceroute', '-m' + str(hops), target])
		return True
	elif command == 'nslookup':
		if not parameters:
			print('Missing parameter: target (optional: server)')
			return True
		target = parameters
		server = None
		if ' ' in parameters:
			param_split = splitCommand(parameters)
			target = param_split[0]
			server = param_split[1]
		ret = sendNetworkNSLookup(target, server)
		if not print_if_error(ret, "to lookup a target (DNS)"):
			if is_var_string(ret):
				print(ret)
			else:
				for line in ret:
					print(line)
		return True
	elif command == 'list':
		if parameters:
			print("No parameters needed, ignoring")
		ret = sendNetworkGetInterface('list')
		if not print_if_error(ret, "to get interface information"):
			if is_var_string(ret):
				print(ret)
			else:
				for line in ret:
					print(line)
		return True
	elif command == 'show':
		if not parameters:
			print('Missing parameter: interface name')
			return True
		ret = sendNetworkGetInterface(parameters)
		if not print_if_error(ret, "to get interface information"):
			if is_var_string(ret):
				print(ret)
			else:
				for line in ret:
					print(line)
		return True
	elif command == 'disable':
		if not parameters:
			print('Missing parameters: Interface name')
			return True
		print_if_error(sendNetworkSetInterfaceDisable(parameters), "to disable interface")
		return True
	elif command == 'static':
		if not parameters:
			print('Missing parameters: Interface name, ip, netmask and gateway')
			return True
		else:
			param_split = parameters.split()
			if len(param_split) != 4:
				print('Missing parameters (Got ' + len(param_split) +  ' - Expected: 4): Interface name, ip, netmask and gateway')
				return True
			print_if_error(sendNetworkSetInterfaceStatic(param_split[0], param_split[1], param_split[2], param_split[3]), "to set interface in static mode")
		return True
	elif command == 'dhcp':
		if not parameters:
			print('Missing parameters: Interface name')
			return True
		print_if_error(sendNetworkSetInterfaceDHCP(parameters), "to set interface in DHCP mode")
		return True
	elif command == 'ids':
		if not parameters:
			print('Missing parameters: Interface name')
			return True
		print_if_error(sendNetworkSetInterfaceIDS(parameters), "to set interface in IDS mode")
		return True
	elif command == 'dns':
		if not parameters:
			ret = sendNetworkGetDNS()
			if not print_if_error(ret, "to get DNS"):
				print(ret)
			return True
		else:
			print_if_error(sendNetworkSetDNS(parameters), "to set DNS")
			return True
		return True
	return False

def parseCustomerInfoCommand(command, parameters):
	if password_token == False:
		return False
	elif command == '?':
		print('sensor <name>                 Get/Set sensor name (logstash and monit)')
		print('email <emails>                Get/Set alert email(s)')
		print('apply                         Apply changes')
		print('name <name>                   Get/Set customer contact name')
		print('phone <phone>                 Get/Set phone number')
		print('location <location>           Get/Set location (city)')
		print('branch <branch>               Get/Set company branch (for multiple offices)')
		print('country <country>             Get/Set country')
		print('note <note>                   Get/Set note')
		sendPing()
		return True
	elif command == 'sensor':
		if parameters:
			print_if_error(sendCISetSensorName(parameters), "setting sensor name")
		else:
			name = sendCIGetSensorName()
			if not print_if_error(name, "getting sensor name"):
				print(name)
		return True
	elif command == 'email':
		if parameters:
			print_if_error(sendCISetEmail(parameters), "setting alert emails")
		else:
			email = sendCIGetEmail()
			if not print_if_error(email, "getting alert emails"):
				print(email)
		return True
	elif command == 'apply':
		if parameters:
			print("No parameters required. Ignoring.")
		print_if_error(sendLogApplySettings(), "applying customer information settings")
		return True
	elif command == 'name':
		if parameters:
			print_if_error(sendCISetContactName(parameters), "setting contact name")
		else:
			name = sendCIGetContactName()
			if not print_if_error(name, "getting contact name"):
				print(name)
		return True
	elif command == 'phone':
		if parameters:
			print_if_error(sendCISetContactPhone(parameters), "setting contact phone")
		else:
			name = sendCIGetContactPhone()
			if not print_if_error(name, "getting contact phone"):
				print(name)
		return True
	elif command == 'location':
		if parameters:
			print_if_error(sendCISetLocation(parameters), "setting location")
		else:
			name = sendCIGetLocation()
			if not print_if_error(name, "getting location"):
				print(name)
		return True
	elif command == 'branch':
		if parameters:
			print_if_error(sendCISetBranch(parameters), "setting branch")
		else:
			name = sendCIGetBranch()
			if not print_if_error(name, "getting branch"):
				print(name)
		return True
	elif command == 'country':
		if parameters:
			print_if_error(sendCISetCountry(parameters), "setting country")
		else:
			name = sendCIGetCountry()
			if not print_if_error(name, "getting country"):
				print(name)
		return True
	elif command == 'note':
		if parameters:
			print_if_error(sendCISetNote(parameters), "setting note")
		else:
			name = sendCIGetNote()
			if not print_if_error(name, "getting note"):
				print(name)
		return True
	return False

def system_internal_check_for(item):
	if item == None:
		return None
	with open('/etc/mainnerve', 'r') as f:
		lines = f.readlines()
		for line in lines:
			if item in line:
				return True
	return False

def parseLogCommand(command, parameters):
	if password_token == False:
		return False
	elif command == '?':
		print('list                          List all logs entries')
		print('types                         List supported log types')
		print('add <type> <proto> <port>     Add log')
		print('delete <type> <proto> <port>  Delete log item')
		print('apply                         Apply changes')
		sendPing()
		return True
	elif command == 'list':
		if parameters:
			print('No parameters needed for list. Ignoring')
		items = sendLogListEnabledItems()

		if items == False:
			print("Failed getting items, login again and retry")
		if items == None:
			print("Invalid login token, login again and retry")
		for item in items:
			print(item)
		return True
	elif command == 'types':
		if parameters:
			print('No parameters needed for list. Ignoring')
		items = sendLogListSupportedTypes()
		if items == False:
			print("Failed getting items, login again and retry")
		if items == None:
			print("Invalid login token, login again and retry")
		for item in items:
			print(item)
		return True
	elif command == 'add':
		if not parameters:
			print('Missing parameters: <type> <protocol> <port>')
			print('Use "list types" to get a list of available types')
			print('NOTE: winlogevent uses tcp protocol')
			return True
		param_split = parameters.split(' ')
		if len(param_split) != 3:
			print('Missing parameters: <type> <protocol> <port>')
			print('NOTE: winlogevent uses tcp protocol')
		else:
			if sendLogAddItem(param_split[0], param_split[1], param_split[2]) == False:
				print("Failed adding item type <" + param_split[0] + "> protocol <" + param_split[1] + "> port <" + param_split[2] + ">" )
		return True
	elif command == 'delete' or command == 'del':
		if not parameters:
			print('Missing parameters: <type> <protocol> <port>')
			return True
		param_split = parameters.split(' ')
		if len(param_split) != 3:
			print('Missing parameters: <type> <protocol> <port>')
		else:
			if sendLogRemoveItem(param_split[0], param_split[1], param_split[2]) == False:
				print("Failed removing item type <" + param_split[0] + "> protocol <" + param_split[1] + "> port <" + param_split[2] + ">" )
		return True
	elif command == 'apply':
		if sendLogApplySettings() == False:
			print("Failed applying settings")
		return True
	return False

def parseSystemCommand(command, parameters):
	if password_token == False:
		return False
	elif command == '?':
		print('status [name]                 Display status of a one or all services')
		print('start <name>                  Start a service')
		print('stop <name>                   Stop a service')
		print('restart <name>                Restart a service')
		print('enable <name>                 Enable a service to start at boot time')
		print('disable <name>                Disable a service from starting at boot time')
		print('regen_ssh_keys                Regenerate SSH keys')
		print('disk_usage                    Show disk usage')
		print('memory_usage                  Show memory usage')
		print('uptime                        Show server uptime')
		print('ps [modifier]                 Show process list')
		print('netstat [listen|open|all]     Display ports (default: all)')
		print('reboot                        Reboot system')
		print('shutdown                      Shutdown system')
		sendPing()
		return True
	elif command == 'disk_usage':
		if len(parameters) != 0:
			print("Ignoring parameter")
		du = sendSystemGetDiskUsage()
		if not isinstance(du, list):
			print_if_error(du, "getting disk usage")
		else:
			for item in du:
				if len(item) > 0:
					print(item)
		return True
	elif command == 'memory_usage':
		if len(parameters) != 0:
			print("Ignoring parameter")
		mu = sendSystemGetMemoryUsage()
		if not isinstance(mu, list):
			print_if_error(mu, "getting memory usage")
		else:
			for item in mu:
				if len(item) > 0:
					print(item)
		return True
	elif command == 'uptime':
		if len(parameters) != 0:
			print("Ignoring parameter")
		print_if_error(sendSystemGetUptime(), "getting uptime")
		return True
	elif command == 'ps':
		ps = sendSystemGetProcessList(parameters)
		if not isinstance(ps, list):
			print_if_error(ps, "getting process list")
		else:
			for item in ps:
				if len(item) > 0:
					print(item)
		return True
	elif command == 'netstat':
		if parameters and parameters not in [ 'listen', 'open', 'all' ]:
			print("Invalid parameter for netstat. Valid values: listen/open/all")
			return True
		netstat = sendSystemGetNetstat(parameters)
		if not isinstance(netstat, list):
			print_if_error(netstat, "getting process list")
		else:
			for item in netstat:
				if len(item) > 0:
					print(item)
		return True
	elif command == 'regen_ssh_keys':
		if len(parameters) != 0:
			print("Ignoring parameter")
		ret = sendSystemRegenSSHKeys()
		if ret == None:
			print("Issue regenerating SSH keys.")
		elif ret == False:
			print("Failed regenerating SSH keys.")
		return True
	elif command == 'status':
		if len(parameters) == 0:
			ret = sendSystemStatus(None)
			if print_if_error(ret, "to get status of all services"):
				return True
		else:
			ret = sendSystemStatus(parameters)
			if print_if_error(ret, "to get status of " + parameters):
				return True
		# Display results (Running first, stopped at the end)
		for key in ret:
			if ret[key]:
				print(key + ': Running' )
		for key in ret:
			if ret[key] == False:
				print(key + ': Stopped!' )
		return True
	elif command == 'start':
		if parameters == None:
			print("Missing service name")
			return True
		ret = sendSystemStartService(parameters)
		if ret == None:
			print("Issue checking parameters when starting service.")
		elif ret == False:
			print("Failed starting service")
		return True
	elif command == 'stop':
		if parameters == None:
			print("Missing service name")
			return True
		ret = sendSystemStopService(parameters)
		if ret == None:
			print("Issue checking parameters when stopping service.")
		elif ret == False:
			print("Failed stopping service")
		return True
	elif command == 'restart':
		if parameters == None:
			print("Missing service name")
			return True
		ret = sendSystemRestartService(parameters)
		if ret == None:
			print("Issue checking parameters when restarting service.")
		elif ret == False:
			print("Failed restarting service")
		return True
	if command == 'reboot':
		if parameters:
			print("No parameter required for reboot, ignoring.")
		sendSystemReboot()
		return True
	elif command == 'shutdown':
		if parameters:
			print("No parameter required for shutdown, ignoring.")
		sendSystemShutdown()
		return True
	elif command == 'enable':
		if parameters == None:
			print("Missing service name")
			return True
		ret = sendSystemEnableService(parameters)
		if ret == None:
			print("Issue enabling service <" + parameters + ">.")
		elif ret == False:
			print("Failed enabling service <" + parameters + ">.")
		return True
	elif command == 'disable':
		if parameters == None:
			print("Missing service name")
			return True
		ret = sendSystemDisableService(parameters)
		if ret == None:
			print("Issue disabling service <" + parameters + ">.")
		elif ret == False:
			print("Failed disabling service <" + parameters + ">.")
		return True
	return False



def printHelp():
	print('?                             Display help')
	print('exit                          Exit shell')
	if not level:
		print('ssh-password <new>            Change ' + getpass.getuser() + ' user password')
		if password_token != False:
			print('disconnect                    Disconnect current user')
			print('network                       Enter network settings')
			print('customer                      Enter customer information')
			print('log                           Enter log settings')
			print('web                           Enter Web interface user management')
			print('system                        Enter System management')
			sendPing()
		else:
			print('connect <user>                Connect to the interface')

	else:
		print('back                          Exit ' + level)
		if password_token != False:
			if level == 'network':
				return parseNetworkCommand('?', '')
			if level == 'log':
				return parseLogCommand('?', '')
			if level == 'customer':
				return parseCustomerInfoCommand('?', '')
			if level == 'web':
				return parseWebCommand('?', '')
			if level == 'system':
				return parseSystemCommand('?', '')
	return True

def parseCommand(command, parameters):
	global level
	if not command:
		return False

	if not level:
		if command == 'connect':
			if not parameters:
				print("Missing login")
			else:
				password = getpass.getpass()
				sendConnect(parameters, password)
			return True
		elif command == 'ssh-password':
			if parameters:
				changeSSHUserPassword(getpass.getuser(), parameters)
			else:
				print("Missing password")
			return True
	else:
		if command == 'back':
			level = ''
			if password_token:
				sendPing()
			return True

	return False

def ParseCommandConnected(command, parameters):
	global level
	if not command:
		return False

	if not level:
		if command == 'disconnect':
			sendDisconnect()
			return True
		if command == 'network' or command == 'log' or command == 'customer' or command == 'web' or command == 'system':
			if parameters:
				sub_command_split = splitCommand(parameters)

				if command == 'network':
					parseNetworkCommand(sub_command_split[0], sub_command_split[1])
				elif command == 'log':
					parseLogCommand(sub_command_split[0], sub_command_split[1])
				elif command == 'customer':
					parseCustomerInfoCommand(sub_command_split[0], sub_command_split[1])
				elif command == 'web':
					parseWebCommand(sub_command_split[0], sub_command_split[1])
				elif command == 'system':
					parseSystemCommand(sub_command_split[0], sub_command_split[1])
			else:
				if password_token:
					sendPing()
				if command == 'ad' and system_internal_check_for('Netforce Logger'):
					return False
				level = command
			return True
	else:
		if level == 'network':
			return parseNetworkCommand(command, parameters)
		elif level == 'log':
			return parseLogCommand(command, parameters)
		elif level == 'customer':
			return parseCustomerInfoCommand(command, parameters)
		elif level == 'web':
			return parseWebCommand(command, parameters)
		elif level == 'system':
			return parseSystemCommand(command, parameters)
	return False


def main():
	print('Welcome to Netforce Defender Shell v0.1')
	print('Type ? for help')
	while True:
		try:
			command = waitForCommand()

			# Always available commands
			if command == '':
				continue
			elif command == 'exit':
				sendDisconnect()
				print("Bye!")
				os._exit(0)
				continue
			elif command == '?':
				printHelp()
				continue

			# Command parsing
			cp = splitCommand(command)
			ret = parseCommand(cp[0], cp[1])
			if ret == False and password_token != False:
				ret = ParseCommandConnected(cp[0], cp[1])
			if ret == False:
				print('ERROR: ' + cp[0] +': Unknown command')
		except:
			pass


if __name__ == "__main__":
	jsonrpclib.config.use_jsonclass = True
	jsonrpclib.config.classes.add(SmallToken)
	main()