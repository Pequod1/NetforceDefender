#!/usr/bin/env python
#   Copyright 2016 MainNerve LLC
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#
#                                 Apache License
#                           Version 2.0, January 2004
#                        http://www.apache.org/licenses/
#
#   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
#
#   1. Definitions.
#
#      "License" shall mean the terms and conditions for use, reproduction,
#      and distribution as defined by Sections 1 through 9 of this document.
#
#      "Licensor" shall mean the copyright owner or entity authorized by
#      the copyright owner that is granting the License.
#
#      "Legal Entity" shall mean the union of the acting entity and all
#      other entities that control, are controlled by, or are under common
#      control with that entity. For the purposes of this definition,
#      "control" means (i) the power, direct or indirect, to cause the
#      direction or management of such entity, whether by contract or
#      otherwise, or (ii) ownership of fifty percent (50%) or more of the
#      outstanding shares, or (iii) beneficial ownership of such entity.
#
#      "You" (or "Your") shall mean an individual or Legal Entity
#      exercising permissions granted by this License.
#
#      "Source" form shall mean the preferred form for making modifications,
#      including but not limited to software source code, documentation
#      source, and configuration files.
#
#      "Object" form shall mean any form resulting from mechanical
#      transformation or translation of a Source form, including but
#      not limited to compiled object code, generated documentation,
#      and conversions to other media types.
#
#      "Work" shall mean the work of authorship, whether in Source or
#      Object form, made available under the License, as indicated by a
#      copyright notice that is included in or attached to the work
#      (an example is provided in the Appendix below).
#
#      "Derivative Works" shall mean any work, whether in Source or Object
#      form, that is based on (or derived from) the Work and for which the
#      editorial revisions, annotations, elaborations, or other modifications
#      represent, as a whole, an original work of authorship. For the purposes
#      of this License, Derivative Works shall not include works that remain
#      separable from, or merely link (or bind by name) to the interfaces of,
#      the Work and Derivative Works thereof.
#
#      "Contribution" shall mean any work of authorship, including
#      the original version of the Work and any modifications or additions
#      to that Work or Derivative Works thereof, that is intentionally
#      submitted to Licensor for inclusion in the Work by the copyright owner
#      or by an individual or Legal Entity authorized to submit on behalf of
#      the copyright owner. For the purposes of this definition, "submitted"
#      means any form of electronic, verbal, or written communication sent
#      to the Licensor or its representatives, including but not limited to
#      communication on electronic mailing lists, source code control systems,
#      and issue tracking systems that are managed by, or on behalf of, the
#      Licensor for the purpose of discussing and improving the Work, but
#      excluding communication that is conspicuously marked or otherwise
#      designated in writing by the copyright owner as "Not a Contribution."
#
#      "Contributor" shall mean Licensor and any individual or Legal Entity
#      on behalf of whom a Contribution has been received by Licensor and
#      subsequently incorporated within the Work.
#
#   2. Grant of Copyright License. Subject to the terms and conditions of
#      this License, each Contributor hereby grants to You a perpetual,
#      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#      copyright license to reproduce, prepare Derivative Works of,
#      publicly display, publicly perform, sublicense, and distribute the
#      Work and such Derivative Works in Source or Object form.
#
#   3. Grant of Patent License. Subject to the terms and conditions of
#      this License, each Contributor hereby grants to You a perpetual,
#      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
#      (except as stated in this section) patent license to make, have made,
#      use, offer to sell, sell, import, and otherwise transfer the Work,
#      where such license applies only to those patent claims licensable
#      by such Contributor that are necessarily infringed by their
#      Contribution(s) alone or by combination of their Contribution(s)
#      with the Work to which such Contribution(s) was submitted. If You
#      institute patent litigation against any entity (including a
#      cross-claim or counterclaim in a lawsuit) alleging that the Work
#      or a Contribution incorporated within the Work constitutes direct
#      or contributory patent infringement, then any patent licenses
#      granted to You under this License for that Work shall terminate
#      as of the date such litigation is filed.
#
#   4. Redistribution. You may reproduce and distribute copies of the
#      Work or Derivative Works thereof in any medium, with or without
#      modifications, and in Source or Object form, provided that You
#      meet the following conditions:
#
#      (a) You must give any other recipients of the Work or
#          Derivative Works a copy of this License; and
#
#      (b) You must cause any modified files to carry prominent notices
#          stating that You changed the files; and
#
#      (c) You must retain, in the Source form of any Derivative Works
#          that You distribute, all copyright, patent, trademark, and
#          attribution notices from the Source form of the Work,
#          excluding those notices that do not pertain to any part of
#          the Derivative Works; and
#
#      (d) If the Work includes a "NOTICE" text file as part of its
#          distribution, then any Derivative Works that You distribute must
#          include a readable copy of the attribution notices contained
#          within such NOTICE file, excluding those notices that do not
#          pertain to any part of the Derivative Works, in at least one
#          of the following places: within a NOTICE text file distributed
#          as part of the Derivative Works; within the Source form or
#          documentation, if provided along with the Derivative Works; or,
#          within a display generated by the Derivative Works, if and
#          wherever such third-party notices normally appear. The contents
#          of the NOTICE file are for informational purposes only and
#          do not modify the License. You may add Your own attribution
#          notices within Derivative Works that You distribute, alongside
#          or as an addendum to the NOTICE text from the Work, provided
#          that such additional attribution notices cannot be construed
#          as modifying the License.
#
#      You may add Your own copyright statement to Your modifications and
#      may provide additional or different license terms and conditions
#      for use, reproduction, or distribution of Your modifications, or
#      for any such Derivative Works as a whole, provided Your use,
#      reproduction, and distribution of the Work otherwise complies with
#      the conditions stated in this License.
#
#   5. Submission of Contributions. Unless You explicitly state otherwise,
#      any Contribution intentionally submitted for inclusion in the Work
#      by You to the Licensor shall be under the terms and conditions of
#      this License, without any additional terms or conditions.
#      Notwithstanding the above, nothing herein shall supersede or modify
#      the terms of any separate license agreement you may have executed
#      with Licensor regarding such Contributions.
#
#   6. Trademarks. This License does not grant permission to use the trade
#      names, trademarks, service marks, or product names of the Licensor,
#      except as required for reasonable and customary use in describing the
#      origin of the Work and reproducing the content of the NOTICE file.
#
#   7. Disclaimer of Warranty. Unless required by applicable law or
#      agreed to in writing, Licensor provides the Work (and each
#      Contributor provides its Contributions) on an "AS IS" BASIS,
#      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
#      implied, including, without limitation, any warranties or conditions
#      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
#      PARTICULAR PURPOSE. You are solely responsible for determining the
#      appropriateness of using or redistributing the Work and assume any
#      risks associated with Your exercise of permissions under this License.
#
#   8. Limitation of Liability. In no event and under no legal theory,
#      whether in tort (including negligence), contract, or otherwise,
#      unless required by applicable law (such as deliberate and grossly
#      negligent acts) or agreed to in writing, shall any Contributor be
#      liable to You for damages, including any direct, indirect, special,
#      incidental, or consequential damages of any character arising as a
#      result of this License or out of the use or inability to use the
#      Work (including but not limited to damages for loss of goodwill,
#      work stoppage, computer failure or malfunction, or any and all
#      other commercial damages or losses), even if such Contributor
#      has been advised of the possibility of such damages.
#
#   9. Accepting Warranty or Additional Liability. While redistributing
#      the Work or Derivative Works thereof, You may choose to offer,
#      and charge a fee for, acceptance of support, warranty, indemnity,
#      or other liability obligations and/or rights consistent with this
#      License. However, in accepting such obligations, You may act only
#      on Your own behalf and on Your sole responsibility, not on behalf
#      of any other Contributor, and only if You agree to indemnify,
#      defend, and hold each Contributor harmless for any liability
#      incurred by, or claims asserted against, such Contributor by reason
#      of your accepting any such warranty or additional liability.
#
#   END OF TERMS AND CONDITIONS
#
#   APPENDIX: How to apply the Apache License to your work.
#
#      To apply the Apache License to your work, attach the following
#      boilerplate notice, with the fields enclosed by brackets "[]"
#      replaced with your own identifying information. (Don't include
#      the brackets!)  The text should be enclosed in the appropriate
#      comment syntax for the file format. We also recommend that a
#      file or class name and description of purpose be included on the
#      same "printed page" as the copyright notice for easier
#      identification within third-party archives.
#
#   Copyright [yyyy] [name of copyright owner]
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

from __future__ import print_function
import time, spwd, crypt, uuid, datetime, getpass, sys, subprocess, os, types, shlex, traceback, socket, stat, base64, hashlib, re
import xml.etree.ElementTree as ET
try:
	from jsonrpclib.SimpleJSONRPCServer import SimpleJSONRPCServer
except:
	print('jsonrpclib package required. Ubuntu: apt-get install python-jsonrpclib')
	# Python3: python3-dnspython
	sys.exit(1)
from pwd import getpwnam
from grp import getgrnam
# apt-get install python-jsonrpclib
# https://github.com/joshmarshall/jsonrpclib
from os import listdir, chown, chmod
from os.path import isfile, join
try:
	import dns.resolver
except:
	print('dnspython package required. Ubuntu: apt-get install python-dnspython')
	# Python3: python3-dnspython
	sys.exit(1)

# 20 minutes expiration
EXPIRE_TIME_DEFAULT=1200

DEFAULT_PORT=8080

# How to use classes with JSONRPClib:
# 1. Copy definition of SmallToken in other clas
# 2. Use JSON class: jsonrpclib.config.use_jsonclass = True
# 3. Register class: jsonrpclib.config.classes.add(SmallToken)
# 4. Do the calls

class SmallToken:
	# UUID token
	token = False

	# Time in seconds before expiration
	expireTime = False

class LoginToken:
	# Last time the token was used
	lastUpdateTime = False

	# User name
	user = False

	# Token info
	token = False

	def updateLastUsedTime(self):
		self.lastUpdateTime = datetime.datetime.now()

	def __init__(self, username, expiration):
		self.token = SmallToken()
		self.token.token = str(uuid.uuid4())
		self.token.expireTime = expiration
		self.user = username
		self.updateLastUsedTime()

tokens = [ ]

def cleanupTokens():
	for t in tokens:
		# Remove expired tokens (3 is so that a token that is still valid will still be valid in 3 seconds)
		if t.lastUpdateTime + datetime.timedelta(t.token.expireTime - 3) < datetime.datetime.now():
			tokens.remove(t)

def isTokenValid(token):
	if token == None or token == False:
		return False

	cleanupTokens()
	for t in tokens:
		# Check if token is valid
		if t.token.token != False and t.token.token == token:
			t.updateLastUsedTime()
			return True
	return False

def is_var_string(var):
	if var == None:
		return False
	try:
		# Python 2
		return isinstance(var, basestring)
	except:
		pass
	# Python 3
	return isinstance(var, str)

def run_cmd_devnull(command):
	if not command:
		return False
	to_run = command
	if is_var_string(command):
		to_run = shlex.split(command, True)
	try:
		devnull = open(os.devnull, 'w')
	except:
		# If sys.version_info >= (3, 3)
		devnull = open(subprocess.DEVNULL, 'w')
	try:
		subprocess.call(to_run, stdout=devnull, stderr=devnull)
	except:
		return False
	finally:
		devnull.close()
	return True

LOG_FILE='/var/log/netforce_shell.log'

def log_command(token, comment):
	function = traceback.extract_stack()[-2][2]
	printed_time = str(datetime.datetime.now())
	with open(LOG_FILE, 'a') as f:
		f.write(printed_time + " " + function + "(token=")
		if token == None or len(str(token)) == 0:
			f.write("None)")
		else:
			f.write(str(token) + ')')
		if comment != None and len(str(comment)) > 0:
			f.write(" - Comment: " + str(comment))
		f.write('\n')


SHUTDOWN_COMMAND = '/sbin/shutdown'

def ping(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return 'pong'

def reboot(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	try:
		return run_cmd_devnull([ SHUTDOWN_COMMAND, "-r", "now"])
	except:
		return False

def shutdown(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	try:
		return run_cmd_devnull([ SHUTDOWN_COMMAND, "now"])
	except:
		return False

def login(user, password):
	log_command(None, "Login attempt for " + str(user))
	time.sleep(3)
	if not user or not password:
		log_command(None, "Login failed for " + str(user) + " - missing user or password")
		return False

	# Only 'mnadmin' and 'sysuser' are allowed
	if not (user == 'mnadmin' or user == 'sysuser'):
		log_command(None, "Login failed for " + str(user) + " - unauthorized user")
		return False

	try:
		hash = spwd.getspnam(user).sp_pwd
	except:
		log_command(None, "Login failed for " + str(user) + " - hashing password failed")
		return False

	hash_split = hash.split('$')

	# Salt
	salt = hash_split[2]

	# Crypto type
	ctype = hash_split[1]
	
	# Check algorithm
	if ctype == '1' or ctype == '2a' or ctype == '5' or ctype == '6':
		# MD5/Blowfish/SHA256/SHA512
		insalt = "$" + ctype + "$" + salt + "$"
		if hash == crypt.crypt(password, insalt):
			# Create new token, it might be a different connection
			new_token = LoginToken(user, EXPIRE_TIME_DEFAULT)
			log_command(new_token.token.token, "Login successful for " + user)
			tokens.append(new_token)
			return new_token.token

	log_command(None, "Login failed for " + str(user) + " - invalid password")
	return False

def logout(token):
	log_command(token, None)
	for t in tokens:
		if t.token.token == token:
			tokens.remove(t)
			return True
	return True


################# WEB STUFF
HTPASSWD_FILE = '/etc/nginx/.htpasswd'

def web_internal_get_user_list():
	entries = web_internal_read_htaccess(None)
	user_list = [ ]
	for entry in entries:
		user_list.append(entry[0])
	return user_list

def web_internal_read_htaccess(ignore_user):
	entries = [ ]
	with open(HTPASSWD_FILE) as f:
		for line in f:
			if line and not line.startswith('#'):
				username, pwhash = line.split(':')
				if ignore_user == None or ignore_user != username:
					entries.append( [username, pwhash.rstrip()])	
	return entries

def web_internal_write_htaccess(entries):
	if entries == None or not isinstance(entries, list):
		return False
	open(HTPASSWD_FILE, 'w').writelines(["%s:%s\n" % (entry[0], entry[1])
													for entry in entries])
	return True

def web_internal_adduser(user, password):
	if not user or not password:
		return False
	# Nginx doesn't support bcrypt and no way we are using a weak algorithm in htpasswd, so using SSHA (Salted SHA1)

	# 1-2. Read file to dictionary and ignore current user
	entries = web_internal_read_htaccess(user)

	# 3. Update/add hash for new user
	salt = os.urandom(4)
	h = hashlib.sha1(password)
	h.update(salt)
	pwhash = base64.encodestring(h.digest() + salt).rstrip()

	entries.append([user, "{SSHA}" + pwhash])

	# 4. Write file back
	return web_internal_write_htaccess(entries)

def web_list(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return web_internal_get_user_list()

def web_adduser(token, user, password):
	log_command(token, "User: " + str(user))
	if isTokenValid(token) == False or not user or not password or user in web_internal_get_user_list():
		return False
	return web_internal_adduser(user, password)

def web_modify_user(token, user, password):
	log_command(token, "User: " + str(user))
	if isTokenValid(token) == False or not user or not password or user not in web_internal_get_user_list():
		return False
	return web_internal_adduser(user, password)

def web_deluser(token, user):
	log_command(token, "User: " + str(user))
	if isTokenValid(token) == False or not user or user not in web_internal_get_user_list():
		return False
	entries = web_internal_read_htaccess(user)
	return web_internal_write_htaccess(entries)

def web_regen_nginx_cert(token, subject):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	if subject != None and len(subject) > 0:
		return run_cmd_devnull([ '/etc/scripts/generate_certificate.sh', subject])
	return run_cmd_devnull([ '/etc/scripts/generate_certificate.sh'])

################## END OF WEB STUFF

################## Logs

_WINLOGEVENT = "winlogevent"
_supported_loggers = [ "cisco", "fortinet", "sophos", "paloalto", "ubiquiti", "aruba", "watchguard", "sonicwall", "barracuda", _WINLOGEVENT ]

_LS_PATH = "/etc/logstash/conf.d"

def log_list_supported_types(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return _supported_loggers

def log_list_enabled(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	# ls /etc/logstash/conf.d/input-*.conf


	input_list = [ ]
	for item in [f for f in listdir(_LS_PATH) if isfile(join(_LS_PATH, f)) and f.startswith("input-")]:
		# Parse the item
		lines = [line.rstrip('\n') for line in open(join(_LS_PATH, item))]
		log_type = ''
		log_protocol = ''
		log_port = ''
		for line in lines:
			stripped_line = line.lstrip()
			if stripped_line == '}' or "input" in stripped_line:
				continue
			if "file" in stripped_line and "{" in stripped_line:
				break
			if stripped_line == 'udp {':
				log_protocol = 'udp'
			elif stripped_line == 'tcp {':
				log_protocol = 'tcp'
			elif stripped_line == 'beats {':
				log_type = _WINLOGEVENT
				# Beats implies TCP protocol
				log_protocol = "tcp"
			elif stripped_line.startswith('type => '):
				log_type = stripped_line.split(' ')[2].strip('\'').strip('"')
			elif stripped_line.startswith('port => '):
				log_port = stripped_line.split(' ')[2].strip('\'').strip('"')
		if log_type and log_protocol and log_port and log_type in _supported_loggers:
			input_list.append(log_protocol + '://' + log_type + ':' + log_port)

	return input_list

def log_internal_verify_variables(log_type, log_protocol, log_port):
	if not log_type or not log_port or not log_protocol:
		return False
	if log_protocol not in [ 'udp', 'tcp' ]:
		return False
	try:
		port = int(str(log_port))
		if port < 1024 or port > 65535:
			return False
	except:
		return False
	if log_type not in _supported_loggers:
		return False
	return True

def log_internal_get_filename_nodir(log_type, log_protocol, log_port):
	if not log_internal_verify_variables(log_type, log_protocol, log_port):
		return None

	for item in [f for f in listdir(_LS_PATH) if isfile(join(_LS_PATH, f)) and f.startswith("input-")]:
		# Parse the item
		lines = [line.rstrip('\n') for line in open(join(_LS_PATH, item))]
		protocol = None
		ltype = None
		lport = None
		for line in lines:
			stripped_line = line.strip()
			if stripped_line == 'udp {':
				protocol = 'udp'
			elif stripped_line == 'tcp {':
				protocol = 'tcp'
			elif stripped_line == 'beats {':
				ltype = _WINLOGEVENT
				# Beats implies TCP protocol
				protocol = "tcp"
			elif stripped_line.startswith('type => '):
				ltype = stripped_line.split(' ')[2].strip('\'').strip('"')
			elif stripped_line.startswith('port => '):
				lport = stripped_line.split(' ')[2].strip('\'').strip('"')

		# Check if it matches
		if protocol == log_protocol and log_type == ltype and str(lport) == str(log_port):
			return item

	return None

def internal_get_listening_ports(protocol):
	if protocol == None or protocol not in [ 'tcp', 'udp' ]:
		return False
	ret = []
	content = []

	# Get data from the IPv4 and IPv6 file
	with open('/proc/net/' + protocol) as f:
		content = f.readlines()
	with open('/proc/net/' + protocol + '6') as f:
		content.extend(f.readlines())

	# Get only the ports that are listening.
	for line in content:
		split_line = line.split()
		if split_line[3] == '0A':
			ip_port = split_line[1].split(':')
			port = int(ip_port[1],16)
			if port not in ret:
				ret.append(port)

	return ret

def internal_is_port_in_use(protocol, port):
	if port == None or protocol == None or protocol not in [ 'tcp', 'udp' ]:
		return False
	int_port = int(port)
	if int_port <= 0 or int_port > 65535:
		return False

	return int(port) in internal_get_listening_ports(protocol)


def log_add_item(token, log_type, log_protocol, log_port):
	log_command(token, "Type: " + str(log_type) + " - Protocol: " + str(log_protocol) + " - Port: " + str(log_port))
	if isTokenValid(token) == False:
		return False
	if not log_internal_verify_variables(log_type, log_protocol, log_port):
		return False
	if log_internal_get_filename_nodir(log_type, log_protocol, log_port) != None:
		return False
	if internal_is_port_in_use(log_protocol, log_port):
		return False

	# Create file 'input-'TYPE'-'PROTO'-'PORT'.conf'
	newfilename = _LS_PATH + '/input-' + log_type + '-' + log_protocol + '-' + str(log_port) + '.conf'

	try:
		f = open(newfilename, 'w')
		if not f:
			return False

		f.write("input {\n")
		if log_type == _WINLOGEVENT:
			f.write("\tbeats {\n")
			f.write("\t\tport => " + str(log_port) + "\n")
		else:
			f.write("\t" + log_protocol + " {\n")
			f.write("\t\ttype => \"" + log_type + "\"\n")
			f.write("\t\tport => " + str(log_port) + "\n")
			if log_protocol == 'udp':
				f.write("\t\tworkers => 5\n")
				f.write("\t\tqueue_size => 100000\n")
		f.write("\t}\n")
		f.write("}")
		# Flush
		f.flush()
		os.fsync(f.fileno())

		# Close
		f.close()
	except:
		try:
			os.remove(newfilename)
		except:
			pass
		return False

	return True

def log_remove_item(token, log_type, log_protocol, log_port):
	log_command(token, "Type: " + str(log_type) + " - Protocol: " + str(log_protocol) + " - Port: " + str(log_port))
	if isTokenValid(token) == False:
		return False
	if not log_internal_verify_variables(log_type, log_protocol, log_port):
		return False
	file_to_remove = log_internal_get_filename_nodir(log_type, log_protocol, log_port)
	if file_to_remove == None:
		return False

	path_to_remove = join(_LS_PATH, file_to_remove)

	try:
		os.remove(path_to_remove)
	except:
		return False
	return not os.path.isfile(path_to_remove)

def log_apply_settings(token):
	log_command(token, None)
	return system_internal_action_service(token, 'logstash', 'stop') and system_internal_action_service(token, 'logstash', 'start')

################## End of Logs

################## Customer information

_CUSTOMER_INFO_FILENAME = 'customer_info.conf'

class CustomerContact:
	name = ''
	email = ''
	phone = ''

class CustomerInfo:
	name = ''
	location = ''
	branch = ''
	country = ''
	note = ''
	cc = CustomerContact()

def internal_getItemInQuotes(item):
	try:
		return item.split('=>')[1].strip().strip('"')
	except:
		return ''

def customer_info_internal_read():
	ret = CustomerInfo()
	lines = [line.strip() for line in open(join(_LS_PATH, _CUSTOMER_INFO_FILENAME))]
	for line in lines:
		if not line.startswith('"'):
			continue
		if line.startswith('"[customer][name]'):
			ret.name = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][location]'):
			ret.location = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][branch]'):
			ret.branch = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][country]'):
			ret.country = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][note]'):
			ret.note = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][contact][name]'):
			ret.cc.name = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][contact][email]'):
			ret.cc.email = internal_getItemInQuotes(line)
		elif line.startswith('"[customer][contact][phone]'):
			ret.cc.phone = internal_getItemInQuotes(line)
	return ret

def customer_info_internal_write_ci(ci):
	if ci == None:
		return False

	try:
		f = open(join(_LS_PATH, _CUSTOMER_INFO_FILENAME), 'w')
		if not f:
			return False

		f.write("filter {\n")
		f.write("\tmutate {\n")
		f.write("\t\tadd_field => {\n")

		f.write('\t\t\t"[customer][name]" => "' + ci.name + '"\n')
		f.write('\t\t\t"[customer][location]" => "' + ci.location + '"\n')
		f.write('\t\t\t"[customer][branch]" => "' + ci.branch + '"\n')
		f.write('\t\t\t"[customer][country]" => "' + ci.country + '"\n')
		f.write('\t\t\t"[customer][note]" => "' + ci.note + '"\n')
		f.write('\t\t\t"[customer][contact][name]" => "' + ci.cc.name + '"\n')
		f.write('\t\t\t"[customer][contact][email]" => "' + ci.cc.email + '"\n')
		f.write('\t\t\t"[customer][contact][phone]" => "' + ci.cc.phone + '"\n')

		f.write("\t\t}\n")
		f.write("\t}\n")
		f.write("}")
		# Flush
		f.flush()
		os.fsync(f.fileno())

		# Close
		f.close()
	except:
		try:
			f.close()
		except:
			pass
		return False

	return True

def are_quotes_in_string(str):
	if not str:
		return False
	return '"' in str

# Set
def customer_info_set_name(token, name):
	log_command(token, str(name))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(name):
		return False
	ci = customer_info_internal_read()
	ci.name = name

	# Update MonitRC file
	content = []
	try: 
		with open('/etc/monit/monitrc') as f:
			for line in f:
				if line.startswith(" subject: ["):
					content.append(" subject: [" + ci.name + "] monit alert -- $EVENT $SERVICE\n")
				else:
					content.append(line)
		with open('/etc/monit/monitrc', 'w') as f:
			for line in content:
				f.write(line)
			system_internal_action_service(token, 'monit', 'restart')
	except:
		return False
	return customer_info_internal_write_ci(ci)

def customer_info_set_location(token, location):
	log_command(token, str(location))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(location):
		return False
	ci = customer_info_internal_read()
	if location == 'remove':
		ci.location = ''
	else:
		ci.location = location
	return customer_info_internal_write_ci(ci)

def customer_info_set_branch(token, branch):
	log_command(token, str(branch))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(branch):
		return False
	ci = customer_info_internal_read()
	if branch == 'remove':
		ci.branch = ''
	else:
		ci.branch = branch
	return customer_info_internal_write_ci(ci)

def customer_info_set_country(token, country):
	log_command(token, str(country))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(country):
		return False
	ci = customer_info_internal_read()
	if country == 'remove':
		ci.country = ''
	else:
		ci.country = country
	return customer_info_internal_write_ci(ci)

def customer_info_set_note(token, note):
	log_command(token, str(note))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(note):
		return False
	ci = customer_info_internal_read()
	if note == 'remove':
		ci.note = ''
	else:
		ci.note = note
	return customer_info_internal_write_ci(ci)

def customer_info_set_contact_name(token, contact_name):
	log_command(token, str(contact_name))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(contact_name):
		return False
	ci = customer_info_internal_read()
	if contact_name == 'remove':
		ci.contact_name = ''
	else:
		ci.cc.name = contact_name
	return customer_info_internal_write_ci(ci)

def customer_info_set_contact_email(token, contact_email):
	log_command(token, str(contact_email))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(contact_email):
		return False
	ci = customer_info_internal_read()
	if contact_email == 'remove':
		ci.contact_email = ''
	else:
		ci.cc.email = contact_email
	return customer_info_internal_write_ci(ci)

def customer_info_set_contact_phone(token, contact_phone):
	log_command(token, str(contact_phone))
	if isTokenValid(token) == False:
		return False
	if are_quotes_in_string(contact_phone):
		return False
	ci = customer_info_internal_read()
	if contact_phone == 'remove':
		ci.contact_phone = ''
	else:
		ci.cc.phone = contact_phone
	return customer_info_internal_write_ci(ci)

# Get
def customer_info_get_name(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().name

def customer_info_get_location(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().location

def customer_info_get_branch(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().branch

def customer_info_get_country(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().country

def customer_info_get_note(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().note

def customer_info_get_contact_name(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().cc.name

def customer_info_get_contact_email(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().cc.email

def customer_info_get_contact_phone(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return customer_info_internal_read().cc.phone

################## End of  Customer information

def internal_is_str_ip(ip):
	if ip == None:
		return False
	try:
		socket.inet_aton(ip)
	except socket.error:
		return False
	return True

################## Network settings

NETWORK_CONFIG_FILE = '/etc/network/interfaces'

def network_internal_is_interface_valid(interface):
	if interface == None:
		return False
	return interface in network_internal_get_interface_list()

def network_internal_get_interface_list():
	iface_list = os.listdir('/sys/class/net/')
	iface_list.remove('lo')
	for iface in iface_list:
		if iface.startswith('dummy') or iface.startswith('tun') or iface.startswith('tap'):
			iface_list.remove(iface)
	return iface_list

def network_internal_get_interface(interface):
	if interface == None:
		return False

	if interface == 'list':
		return network_internal_get_interface_list()

	if not network_internal_is_interface_valid(interface):
		return False
	ip = None
	netmask = None
	gateway = None
	with open(NETWORK_CONFIG_FILE) as f:
		static_iface = False
		for line in f:
			if line.startswith('iface ' + interface + ' inet '):
				iface_type = line.split()[3]
				if iface_type == 'manual':
					return 'IDS'
				elif iface_type == 'static':
					static_iface = True
					continue
				elif iface_type == 'dhcp':
					return 'DHCP'
				return 'Unknown: ' + iface_type
			elif static_iface:
				if line.startswith('#')  or line == '':
					continue
				if line.startswith('auto') or line.startswith('dns') or line.startswith('iface'):
					break
				if 'address' in line:
					ip = line.strip().split()[1]
				elif 'netmask' in line:
					netmask = line.strip().split()[1]
				elif 'gateway' in line:
					gateway = line.strip().split()[1]
	if static_iface:
		if ip == None or netmask == None or gateway == None:
			return "Invalid static interface. Set interface settings to fix it (static, DHCP or IDS)."
		return 'IP: ' + ip + ' - Netmask: ' + netmask + ' - Gateway: ' + gateway
	else:
		return 'Disabled'
	return False

def network_get_interface(token, interface):
	log_command(token, str(interface))
	if isTokenValid(token) == False:
		return False
	return network_internal_get_interface(interface)


# Limitation: cannot only handle a single gateway
# Those systems will need manual configuration by us
def network_internal_replace_settings_of(interface, settings):
	if settings == None or network_internal_is_interface_valid(interface) == False:
		return False
	config_content = []

	# Read file and ignore part where our interface has settings
	with open(NETWORK_CONFIG_FILE) as f:
		ignore_until_next = False
		for line in f:
			if ignore_until_next:
				if line.startswith('auto') or line.startswith('iface') or line.startswith('dns'):
					ignore_until_next = False
				else:
					continue
			if line.startswith('auto ' + interface):
				continue
			if line.startswith('iface ' + interface + ' inet '):
				ignore_until_next = True
				continue
			config_content.append(line)

	# Update settings
	with open(NETWORK_CONFIG_FILE, 'w') as f:
		last_line_is_newline = False
		for line in config_content:
			if last_line_is_newline and line == '\n':
				continue
			f.write(line)
			last_line_is_newline = (line == '\n')
		if not last_line_is_newline and len(settings) > 0:
			f.write('\n')
		for line in settings:
			f.write(line)
	return True

SNORT_DEBIAN_CONFIG = '/etc/snort/snort.debian.conf'

def network_internal_update_snort_interfaces():
	if system_internal_check_for("Netforce Logger"):
		return True
	iface_list = []
	try:
		# Get interfaces in 'IDS' mode
		for interface in network_internal_get_interface_list():
			if network_internal_get_interface(interface) == 'IDS':
				iface_list.append(interface)
		new_ifaces = ' '.join(iface_list)

		# Check 
		snort_debian_content = []
		with open(SNORT_DEBIAN_CONFIG) as f:
			for line in f:
				if line.startswith('DEBIAN_SNORT_INTERFACE'):
					if new_ifaces == line.split('=')[1].strip('"'):
						return True
					else:
						snort_debian_content.append('DEBIAN_SNORT_INTERFACE="' + new_ifaces + '"\n')
				else:
					snort_debian_content.append(line)
		# Update file
		with open(SNORT_DEBIAN_CONFIG, 'w') as f:
			for line in snort_debian_content:
				f.write(line)
	except:
		return False

	# No need to restart snort since it will be taken care of at reboot time and
	# in order to apply network changes, a reboot/shutdown is necessary as explained
	# in our documentation
	return True

NETMASK_LIST=[ '0.0.0.0', '128.0.0.0', '192.0.0.0', '224.0.0.0', '240.0.0.0', '248.0.0.0', '252.0.0.0', '254.0.0.0', '255.0.0.0', '255.128.0.0', '255.192.0.0', '255.224.0.0', '255.240.0.0', '255.248.0.0', '255.252.0.0', '255.254.0.0', '255.255.0.0', '255.255.128.0', '255.255.192.0', '255.255.224.0', '255.255.240.0', '255.255.248.0', '255.255.252.0', '255.255.254.0', '255.255.255.0', '255.255.255.128', '255.255.255.192', '255.255.255.224', '255.255.255.240', '255.255.255.248', '255.255.255.252', '255.255.255.254', '255.255.255.255' ]

def network_set_interface_static(token, interface, ip, netmask, gateway):
	log_command(token, "Interface: " + str(interface) + " - IP: " + str(ip) + " - Netmask: " + str(netmask) + " - GW: " + str(gateway))
	if ip == None or netmask == None or gateway == None or isTokenValid(token) == False or network_internal_is_interface_valid(interface) == False:
		return False
	if not internal_is_str_ip(ip) or not internal_is_str_ip(gateway) or netmask not in NETMASK_LIST or ip == gateway:
		return False
	to_write = []
	to_write.append('auto ' + interface + '\n')
	to_write.append('iface ' + interface + ' inet static\n')
	to_write.append('\taddress ' + ip + '\n')
	to_write.append('\tnetmask ' + netmask + '\n')
	to_write.append('\tgateway ' + gateway + '\n')
	return network_internal_replace_settings_of(interface, to_write) and network_internal_update_snort_interfaces()

def network_set_interface_disable(token, interface):
	log_command(token, str(interface))
	if isTokenValid(token) == False or network_internal_is_interface_valid(interface) == False:
		return False
	return network_internal_replace_settings_of(interface, [ '' ]) and network_internal_update_snort_interfaces()


def network_set_interface_dhcp(token, interface):
	log_command(token, str(interface))
	if isTokenValid(token) == False or network_internal_is_interface_valid(interface) == False:
		return False
	to_write = []
	to_write.append('auto ' + interface + '\n')
	to_write.append('iface ' + interface + ' inet dhcp\n')
	return network_internal_replace_settings_of(interface, to_write) and network_internal_update_snort_interfaces()

def network_internal_lro_gro_off_for_all():
	# Return true if all interface have LRO and GRO off
	# The easiest way to check is to count the amount of manual, gro and lro instances.
	# We should have as many lro as gro and that count should match the amount of interface in manual mode
	lines = [line.rstrip('\n') for line in open(NETWORK_CONFIG_FILE)]
	manual_count = 0
	gro_count = 0
	lro_count = 0
	for line in lines:
		if line.endswith('inet manual'):
			manual_count += 1
		elif line.endswith('gro off'):
			gro_count += 1
		elif line.endswith('lro off'):
			lro_count += 1
	return manual_count > 0 and manual_count == gro_count and gro_count == lro_count

def network_internal_update_daq_snort():
	SNORT_DEFAULT_FILE = '/etc/default/snort'
	write_back_to_file = False
	lines = [line.rstrip('\n') for line in open(SNORT_DEFAULT_FILE)]
	contains_daq_params = (len([s for s in lines if 'PARAMS="--daq afpacket ' in s]) == 1)
	
	# If all IDS interfaces have LRO and GRO be turned off, then we can use DAQ in snort, thus using afpacket which saves CPU
	if network_internal_lro_gro_off_for_all():
		# Update /etc/default/snort and add '--daq afpacket '
		if not contains_daq_params:
			if len([s for s in lines if s.startswith('PARAMS="')]) == 1:
				# Update and add DAQ
				lines = [ lines.replace('PARAMS="', 'PARAMS="--daq afpacket ') for line in lines]
				write_back_to_file = True
			else:
				# Append
				with open(SNORT_DEFAULT_FILE, 'a') as ofile:
					ofile.write('\nPARAMS="--daq afpacket "\n')
	elif contains_daq_params:
		# Remove DAQ
		lines = [ lines.replace('PARAMS="--daq afpacket ', 'PARAMS="') for line in lines]
		write_back_to_file = True

	if write_back_to_file:
		with open(SNORT_DEFAULT_FILE, 'w') as ofile:
			ofile.writelines(lines)

	return True

def network_set_interface_ids(token, interface):
	log_command(token, str(interface))
	if isTokenValid(token) == False or network_internal_is_interface_valid(interface) == False:
		return False
	to_write = []
	to_write.append('auto ' + interface + '\n')
	to_write.append('iface ' + interface + ' inet manual\n')
	to_write.append('\tup ifconfig $IFACE 0.0.0.0 up\n')
	to_write.append('\tup ip link set $IFACE promisc on\n')
	to_write.append('\tdown ip link set $IFACE promisc off\n')
	to_write.append('\tdown ifconfig $IFACE down\n')
	for line in subprocess.check_output([ 'ethtool', '-k', interface], stderr=subprocess.STDOUT).split('\n'):
		if '[fixed]' in line:
			continue
		if line.startswith('generic-receive-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE gro off\n')
		elif line.startswith('large-receive-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE lro off\n')
		elif line.startswith('tcp-segmentation-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE tso off\n')
		elif line.startswith('generic-segmentation-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE gso off\n')
		elif line.startswith('rx-vlan-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE rxvlan off\n')
		elif line.startswith('tx-vlan-offload'):
			to_write.append('\tpost-up ethtool -K $IFACE txvlan off\n')

	return network_internal_replace_settings_of(interface, to_write) and network_internal_update_snort_interfaces() and network_internal_update_daq_snort()

def network_get_dns(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	with open(NETWORK_CONFIG_FILE) as f:
		for line in f:
			if line.strip().startswith('dns-nameservers '):
				return line.strip().split(' ', 1)[1]
	return 'none'

def network_set_dns(token, dns):
	log_command(token, str(dns))
	if isTokenValid(token) == False or dns == None:
		return False

	# Check DNS
	if dns != 'remove':
		for item in dns.split():
			if not internal_is_str_ip(item):
				return False

	# Get content of file minus dns-nameserver
	dns_found = False
	lines = []
	with open(NETWORK_CONFIG_FILE) as f:
		for line in f:
			if line.strip().startswith('dns-nameservers '):
				dns_found = True
				# If DNS is identical to what we're setting it to, just exit
				if line.strip().split(' ', 1)[1] == dns:
					return True
			else:
				lines.append(line)

	# If it has to be removed and it is not there, there is nothing to do
	if dns == 'remove' and dns_found == False:
		return True

	# Rewrite the file
	with open(NETWORK_CONFIG_FILE, 'w') as f:
		for line in lines:
			f.write(line)
		# And append DNS entry
		if dns != 'remove':
			f.write('dns-nameservers ' + dns + '\n')
	return True

def internal_get_int_value(item, default_value):
	if item == None:
		return default_value
	try:
		return int(item)
	except:
		return default_value

def internal_is_command_injection(command):
	if command == None or len(command) == 0:
		return False
	if ';' in command or '&' in command or '|' in command or '\\' in command or '#' in command:
		return True
	return False

def network_do_ping(token, target, count):
	log_command(token, "Target: " + str(target) + " - Count: " + str(count))
	if isTokenValid(token) == False or target == None:
		return False
	if internal_is_command_injection(target):
		return False
	ping_count = internal_get_int_value(count, 4)

	try:
		return subprocess.check_output(['/bin/ping', target, '-c', str(count)])
	except:
		return None

def network_do_traceroute(token, target, max_hops):
	log_command(token, "Target: " + str(target) + " - Max hops: " + str(max_hops))
	if isTokenValid(token) == False or target == None:
		return False
	if internal_is_command_injection(target):
		return False
	hops = internal_get_int_value(max_hops, 30)
	try:
		return subprocess.check_output(['/usr/sbin/traceroute', '-m' + str(hops), target])
	except:
		return None

def get_resolvers():
	resolvers = []
	try:
		with open( '/etc/resolv.conf', 'r' ) as resolvconf:
			for line in resolvconf.readlines():
				if 'nameserver' in line:
					resolvers.append( line.split( ' ' )[ 1 ].strip() )
		return resolvers
	except IOError as error:
		return None

def network_do_nslookup(token, target, server):
	log_command(token, "Target: " + str(target) + " - Server: " + str(server))
	if isTokenValid(token) == False or target == None:
		return False
	resolver = dns.resolver.Resolver()

	# Ignore server if blank or empty
	try:
		if server == None or len(server.strip()) != 0:
			res = get_resolvers()
			if res == None:
				resolver.nameservers = [ '8.8.8.8' ]
			else:
				resolver.nameservers = get_resolvers()
		else:
			resolver.nameservers = [ server ]
	except:
		return False

	try:
		aquery = resolver.query(target, 'A')
		ip_list = list()
		for i in aquery.response.answer:
			for item in i.items:
				ip_list.append(item.to_text())
		return ip_list
	except dns.resolver.NXDOMAIN as nx_domain_e:
		return None
	except dns.resolver.NoAnswer as noanswer_f:
		return None
	except dns.resolver.Timeout as t:
		return None
	except dns.resolver.NoNameservers as nnse:
		return None
	except dns.resolver.YXDOMAIN as yxdomaine:
		return None
	except Exception as dig_gen_exception:
		log_command(token, "Target: " + str(target) + " - Server: " + str(server) + " - Exception: " + str(dig_gen_exception))
	return None

def network_do_whois(token, domain):
	log_command(token, str(domain))
	if isTokenValid(token) == False or domain == None:
		return False
	if internal_is_command_injection(domain):
		return False
	try:
		return subprocess.check_output(['/usr/bin/whois', domain])
	except:
		return None

################## End of network settings

################## System

ITEMS_WITH_STATUS = [ 'logstash', 'elasticsearch', 'kibana', 'snort', 'elastalert', 'mysql', 'monit', 'nginx', 'ntp', 'ntpd', 'openvpn', 'openvas-manager', 'openvas-scanner', 'openvas-gsa', 'redis', 'ntopng' ]
OPENVPN_PID_DIR = '/run/openvpn'

def system_internal_read_file_get_pid(filename):
	try:
		with open(filename) as f:
			return int(f.read())
	except:
		pass
	return -1

def system_internal_check_for(item):
	if item == None:
		return None
	with open('/etc/mainnerve', 'r') as f:
		lines = f.readlines()
		for line in lines:
			if item in line:
				return True
	return False

def system_internal_is_prog_in_pid(pids, program):
	if program == None or pids == None:
		return False
	for pid in pids:
		try:
			with open("/proc/" + str(pid) + "/cmdline") as f:
				line = f.readline()
			if program in line:
				return True
		except:
			pass
	return False

def system_internal_get_all_statuses():
	pids = [int(pid) for pid in os.listdir('/proc') if pid.isdigit()]
	items = {}
	items['ntopng'] = system_internal_read_file_get_pid('/var/run/ntopng.pid') in pids
	items['ElasticSearch'] = system_internal_read_file_get_pid('/var/run/elasticsearch/elasticsearch.pid') in pids
	items['Logstash'] = system_internal_read_file_get_pid('/var/run/logstash.pid') in pids
	items['MySQL'] = system_internal_read_file_get_pid('/var/run/mysqld/mysqld.pid') in pids
	items['Monit'] = system_internal_read_file_get_pid('/var/run/monit.pid') in pids
	items['Nginx'] = system_internal_read_file_get_pid('/var/run/nginx.pid') in pids
	items['Postfix'] = system_internal_read_file_get_pid('/var/lib/postfix/master.lock') in pids
	items['NTPd'] = system_internal_read_file_get_pid('/var/run/ntpd.pid') in pids

	# Pid doesn't exist, so use alternate method
	items['Kibana'] = system_internal_is_prog_in_pid(pids, "kibana")
	items['Elastalert'] = system_internal_is_prog_in_pid(pids, "elastalert.elastalert")

	# If using Logger or no interface is configured, don't check for snort
	if not system_internal_check_for("Netforce Logger"):
		for interface in network_internal_get_interface_list():
			if network_internal_get_interface(interface) == 'IDS':
				items['Snort (' + interface + ')'] =  system_internal_read_file_get_pid('/var/run/snort_' + interface + '.pid') in pids

	# OpenVAS has 4 processes: gsad, openvassd, openvasmd and redis-server
	items['OpenVAS-GSA'] = system_internal_read_file_get_pid('/var/run/gsad.pid') in pids
	items['OpenVAS-Scanner'] = system_internal_read_file_get_pid('/var/run/openvassd.pid') in pids
	items['OpenVAS-Manager'] = system_internal_read_file_get_pid('/var/run/openvasmd.pid') in pids
	items['Redis'] = system_internal_read_file_get_pid('/var/run/redis/redis-server.pid') in pids

	try:
		items['OpenVPN'] = len(os.listdir(OPENVPN_PID_DIR)) > 0
	except:
		pass

	return items

def system_internal_get_status(item):
	if item == None or item.lower() not in ITEMS_WITH_STATUS:
		return False
	if item.lower() == 'openvpn' and not os.path.isdir(OPENVPN_PID_DIR):
		return False
	if item.lower() == 'rabbitmq' and system_internal_check_for("Adaptive Darknet"):
		return False
	if system_internal_check_for("Netforce Logger"):
		if item.lower() == 'quagga' or item.lower() == 'snort':
			return False

	items_status = system_internal_get_all_statuses()

	ret = {}
	for key in items_status:
		if key.lower().startswith(item.lower()):
			ret[key] = items_status[key]
	return ret

def system_status(token, item):
	log_command(token, str(item))
	if isTokenValid(token) == False:
		return False

	if item == None:
		# status of all items
		return system_internal_get_all_statuses()

	return system_internal_get_status(item)

def system_internal_action_service(token, item, action):
	if isTokenValid(token) == False or item == None or action == None or action not in ['start', 'stop', 'restart']:
		return None

	item_lower = item.lower()

	if item_lower == 'openvpn' and not os.path.isdir(OPENVPN_PID_DIR):
		return False
	if item_lower == 'rabbitmq' and system_internal_check_for("Adaptive Darknet"):
		return False
	if system_internal_check_for("Netforce Logger"):
		if item_lower == 'quagga' or item_lower == 'snort':
			return False

	# Check if we really need to start/stop the service
	status = system_internal_get_status(item_lower)
	if status == False:
		return None

	some_running = False
	some_stopped = False

	for key in status:
		if status[key] == False:
			some_stopped = True
		else:
			some_running = True

	if action == 'stop':
		if some_running:
			pass
		elif some_stopped:
			return True
	elif action == 'start':
		if some_stopped:
			pass
		elif some_started:
			return True

	# Start/stop service
	if item_lower == 'rabbitmq' or item_lower == 'redis':
		item_lower += '-server'
	elif item_lower == 'ntpd':
		item_lower = 'ntp'

	return run_cmd_devnull(['/usr/sbin/service', item_lower, action])

def system_start_service(token, item):
	log_command(token, str(item))
	if isTokenValid(token) == False:
		return False
	return system_internal_action_service(token, item, 'start')

def system_stop_service(token, item):
	log_command(token, str(item))
	if isTokenValid(token) == False:
		return False
	return system_internal_action_service(token, item, 'stop')

def system_restart_service(token, item):
	log_command(token, str(item))
	if isTokenValid(token) == False:
		return False
	return system_internal_action_service(token, item, 'stop') and system_internal_action_service(token, item, 'start')

def system_internal_enable_disable_service(enable, service):
	if service == None or (service.lower() not in ITEMS_WITH_STATUS and service.lower() != 'openvas'):
		return False
	service_lower = service.lower()

	# OpenVAS is a special case, it has 4 services
	if service_lower == 'openvas':
		return system_internal_enable_disable_service(enable, 'redis') and system_internal_enable_disable_service(enable, 'openvas-gsa') and system_internal_enable_disable_service(enable, 'openvas-manager') and system_internal_enable_disable_service(enable, 'openvas-scanner')

	# A few other special cases where service name is different
	if service_lower == 'rabbitmq' or service_lower == 'redis':
		service_lower += '-server'
	elif service_lower == 'ntpd':
		service_lower = 'ntp'

	if enable:
		return run_cmd_devnull([ '/bin/systemctl', 'enable', service_lower])

	return run_cmd_devnull([ '/bin/systemctl', 'disable', service_lower])

def system_enable_service(token, service):
	log_command(token, str(service))
	if isTokenValid(token) == False:
		return False
	return system_internal_enable_disable_service(True, service)

def system_disable_service(token, service):
	log_command(token, str(service))
	if isTokenValid(token) == False:
		return False
	return system_internal_enable_disable_service(False, service)

def system_regen_ssh_keys(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return run_cmd_devnull([ '/etc/scripts/regenerate_ssh_keys.sh'])

def system_get_disk_usage(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	# os.statvfs('/') -> .f_bfree*.f_bsize
	return subprocess.check_output([ 'df', '-h' ], stderr=subprocess.STDOUT).split('\n')

def system_get_memory_usage(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	return subprocess.check_output([ 'free', '-h' ], stderr=subprocess.STDOUT).split('\n')

def system_get_uptime(token):
	log_command(token, None)
	if isTokenValid(token) == False:
		return False
	uptime = subprocess.check_output([ 'uptime' ], stderr=subprocess.STDOUT)
	return uptime.strip()


def system_get_ps(token, modifier):
	log_command(token, modifier)
	if isTokenValid(token) == False:
		return False
	# Only allow letters and numbers
	if modifier != None and len(modifier) > 0:
		if re.match('^[A-Za-z0-9]+$', modifier):
			return subprocess.check_output([ 'ps', modifier ], stderr=subprocess.STDOUT).split('\n')
		return False
	return subprocess.check_output([ 'ps' ], stderr=subprocess.STDOUT).split('\n')

def system_get_netstat(token, option):
	log_command(token, option)
	if isTokenValid(token) == False:
		return False
	new_output = [ ]

	# Get netstat output and clean it up (and remove unix sockets)
	netstat = []
	process_option = '-anp'
	if option == 'listen':
		process_option = '-lnp'
	for line in subprocess.check_output([ 'netstat', process_option ], stderr=subprocess.STDOUT).split('\n'):
		if line.startswith('Active Internet'):
			continue
		if line.startswith('Active UNIX'):
			break
		netstat.append(line)

	if option != None and len(option) > 0:
		if option not in [ 'open', 'listen', 'all']:
			return False
		if option == 'open':
			return [ line for line in netstat if 'LISTEN' not in line ]

	return netstat



################## End of status

def main():
	print("Configuring server and registering functions")
	log_command(None, "Configuring server and registering functions")
	server = SimpleJSONRPCServer(('localhost', DEFAULT_PORT))
	server.register_function(login)
	server.register_function(logout)
	server.register_function(reboot)
	server.register_function(shutdown)
	server.register_function(ping)

	# Web
	server.register_function(web_list)
	server.register_function(web_adduser)
	server.register_function(web_modify_user)
	server.register_function(web_deluser)
	server.register_function(web_regen_nginx_cert)

	# Log
	server.register_function(log_list_supported_types)
	server.register_function(log_list_enabled)
	server.register_function(log_add_item)
	server.register_function(log_remove_item)
	server.register_function(log_apply_settings)

	# Customer info
	server.register_function(customer_info_set_name)
	server.register_function(customer_info_set_location)
	server.register_function(customer_info_set_branch)
	server.register_function(customer_info_set_country)
	server.register_function(customer_info_set_note)
	server.register_function(customer_info_set_contact_name)
	server.register_function(customer_info_set_contact_email)
	server.register_function(customer_info_set_contact_phone)

	server.register_function(customer_info_get_name)
	server.register_function(customer_info_get_location)
	server.register_function(customer_info_get_branch)
	server.register_function(customer_info_get_country)
	server.register_function(customer_info_get_note)
	server.register_function(customer_info_get_contact_name)
	server.register_function(customer_info_get_contact_email)
	server.register_function(customer_info_get_contact_phone)
	
	# Network settings
	server.register_function(network_get_interface)
	server.register_function(network_set_interface_static)
	server.register_function(network_set_interface_disable)
	server.register_function(network_set_interface_dhcp)
	server.register_function(network_set_interface_ids)
	server.register_function(network_get_dns)
	server.register_function(network_set_dns)

	server.register_function(network_do_ping)
	server.register_function(network_do_traceroute)
	server.register_function(network_do_nslookup)
	server.register_function(network_do_whois)

	# System
	server.register_function(system_status)
	server.register_function(system_start_service)
	server.register_function(system_stop_service)
	server.register_function(system_restart_service)
	server.register_function(system_enable_service)
	server.register_function(system_disable_service)
	server.register_function(system_regen_ssh_keys)
	server.register_function(system_get_disk_usage)
	server.register_function(system_get_memory_usage)
	server.register_function(system_get_uptime)
	server.register_function(system_get_ps)
	server.register_function(system_get_netstat)

	try:
		print("Starting server on port " + str(DEFAULT_PORT))
		log_command(None, "Starting server on port " + str(DEFAULT_PORT))
		server.serve_forever()
	except KeyboardInterrupt:
		log_command(None, "Keyboard interrupt, exiting")
		pass
	except:
		log_command(None, "Failed to start server, exiting")
		print("Failed to start server, exiting")

if __name__ == "__main__":
	if getpass.getuser() != 'root':
		print("Root is required. Aborting!")
		sys.exit(1)
	main()